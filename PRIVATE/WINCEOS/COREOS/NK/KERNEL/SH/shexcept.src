;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Use of this source code is subject to the terms of the Microsoft shared
; source or premium shared source license agreement under which you licensed
; this source code. If you did not accept the terms of the license agreement,
; you are not authorized to use this source code. For the terms of the license,
; please see the license agreement between you and Microsoft or, if applicable,
; see the SOURCE.RTF on your install media or the root of your tools installation.
; THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
;
        .HEADING "SH Interrupt and Exception Processing"
;++
;
;
; Module Name:
;
;    shexcept.src
;
; Abstract:
;
;    This module implements the code necessary to field and process SH
;    interrupt and exception conditions.
;
;    WARNING: This module executes in KSEG0 and, in general, cannot
;       tolerate a TLB Miss. Registers k0 and k1 are used during initial
;       interrupt and exception processing, and therefore, extreme care must
;       be exercised when modifying this module.
;
; Revision History:
;
;--

        .list OFF
        .include "ksshx.h"
        .list ON

INTRLOCK_LEDS: .equ 0

PERFORMCALLBACK:        .equ   -30
CALLEE_SAVED_REGS:      .equ    32      ; (7 registers)  {r8-r14}, add 1 to make 8 byte alignment)
CST_MODE_FROM_USER      .equ    1

; must match the value in kernel.h
SECURESTK_RESERVE:      .equ    112     ; SIZE_PRETLS + SIZE_CRTSTORAGE + 16
MAX_PSL_ARGS:           .equ    56

VM_SHARED_HEAP_BASE:    .equ    h'70000000      ; shared heap start (r/o for user, r/w for kernel)
READONLY_MASK           .equ    h'ffffffdf      ; == ~0x20 (mask to clear write bit)
READWRITE_MASK          .equ    h'ffffffff      ;

API_MAX: .equ   FIRST_METHOD - (h'7fff * 2)


        .import _DumpFrame
        .import _HandleException
        .import _KernelInit
        .import _NextThread
        .import _KCNextThread
        .import _RunList
        .import _SleepList
        .import _ObjectCall
        .import _ServerCallReturn
        .import _SHInit
        .import _ExceptionDispatch
        .import _SetCPUASID
        .import _OEMIdle
        .import _NKCallIntChainWrapped
        .import _SetupCallToUserServer
        .import _NKPrepareCallback
        
        .import _g_pfnUsrRtlDispExcp
        .import _g_pfnKrnRtlDispExcp
        .import _g_pprcNK

        .import _dwStoreQueueBase

  .aif NKPROF eq h'01
        .import _CELOG_Interrupt        
  .aendi

        ;; for ISR hook
        .import _OEMNotifyIntrOccurs

        .PAGE
        .section .data,data
        .align  4
        .export _InterruptTable
        .export _ExceptionTable
_ExceptionTable:
        .data.l _UnusedHandler          ; 0x000 power-on reset (intr resched)
        .data.l _UnusedHandler          ; 0x020 manual restart
        .data.l _UnusedHandler          ; 0x040 TLB miss load
        .data.l _UnusedHandler          ; 0x060 TLB miss store
        .data.l _UnusedHandler          ; 0x080 initial page write
        .data.l _UnusedHandler          ; 0x0A0 TLB protection violation (load)
        .data.l _UnusedHandler          ; 0x0c0 TLB protection violation (store)
        .data.l _UnusedHandler          ; 0x0e0 address error (load)
        .data.l _UnusedHandler          ; 0x100 address error (store)
        .data.l _UnusedHandler          ; 0x120 reserved
        .data.l _UnusedHandler          ; 0x140 reserved
        .data.l _UnusedHandler          ; 0x160 TRAPA instruction
        .data.l _UnusedHandler          ; 0x180 reserved instruction
        .data.l _UnusedHandler          ; 0x1A0 invalid delay slot instruction
        .data.l _UnusedHandler          ; 0x1C0 NMI (general interrupt request)        
        .data.l _UnusedHandler          ; 0x1E0 user breakpoint (HW breakpoints)
_InterruptTable:
        .arepeat 496                    ; 512(total)-16(system exceptions) HW interrupts
        .data.l _UnusedHandler
        .aendr

_bEnableRAMMode:
        .res.l 1
;--------- Work around for SH4 sleep problem. ----------------------------------
fInIdle:
        .data.l 0
        
 .export _IntrPrio
	.data.b 0xf,0xf,0xf,0xf
_IntrPrio:
        .data.b 0xf,0xe,0xd,0xc,0xb,0xa,0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x2,0x1,0x0 ; 0x200-0x3e0
        .arepeat 480                            ; 512(total)-16(system exceptions)-16(defined above)
        .data.b 0x1
        .aendr

        .section .KDATA,stack
        .export _KDBase
        .export _KStack
_KDBase: .res.b h'1000  ; reserve an extra page for the debugger
         .res.b h'7e0
_KStack: .res.l 8
        .export _KData
_KData: .res.b  h'800

        .section .text,code,align=16

KPAGE_PTEL: .equ _KData + h'14a ; user read-only, 1k, cachable, !dirty, shared, valid

PR_B1_BK: .equ h'70008000       ; privileged mode, bank 1, exceptions blocked
PR_B0_IE: .equ h'40008000       ; privileged mode, bank 0, un-blocked, intr unmasked
PR_B0_IM: .equ h'400080f0       ; privileged mode, bank 0, un-blocked, intr masked
PR_B0_BK: .equ h'50008000       ; privileged mode, bank 0, exceptions blocked
ALPHA_LED: .equ h'A4010060	; LED start address

        START_REGION    ExceptionBase   ; base to load into VBR

;-------------------------------------------------------------------------------
;
; Generate a debug break instruction
;
;-------------------------------------------------------------------------------

        LEAF_ENTRY _DebugBreak
        trapa   #1
        rts
        nop
        .endf

;-------------------------------------------------------------------------------
;
; Enable interrupts
;
;-------------------------------------------------------------------------------

        LEAF_ENTRY _INTERRUPTS_ON
        mov     #h'ffffff0f, r1
        stc     SR, r0
        and     r1, r0
        ldc     r0, SR
        rts
        nop
        .endf

;-------------------------------------------------------------------------------
;
; Disable interrupts
;
;-------------------------------------------------------------------------------

        LEAF_ENTRY _INTERRUPTS_OFF
        stc     SR, r0
        or      #h'f0, r0
        ldc     r0, SR
        rts
        nop
        .endf   

;-------------------------------------------------------------------------------
;
; SHSetASID - set address space id
; void SHSetASID (DWORD dwASID)
;
; Set process ASID in the MMU register
;
;-------------------------------------------------------------------------------

        LEAF_ENTRY _SHSetASID
        mov    #SH3CTL_BASE, r7
	mov.l  r4, @(MMUPTEH,r7)
        rts
        nop
        .endf

;-------------------------------------------------------------------------------
;
; SetCPUGlobals ()
; Saves the current thread pointer to the register r4 in bank1
;
;-------------------------------------------------------------------------------

        LEAF_ENTRY _SetCPUGlobals
        mov    #_KData+pCurThd, r0
        mov    @r0, r0
        ldc    r0, r4_bank
        rts
        nop
        .endf

        .PAGE

;-------------------------------------------------------------------------------
;
; NKStartup(struct KDataStruct *const pProtoKData, DWORD_PTR dwOEMInitGlobals)
;
; Called by nkloader to start the kernel. This should exchange globals with
; oal, load kitl,initialize RAM, initialize the kernel process/mainthread, and 
; start the first thread in the kernel.
;
; This function call does not return.
;
; On entry, the state of the processor is:
; (SR) = PR_B1_BK: Priveleged, interrupts are blocked and registers are in bank 1
; (r4) = ptr to pKData hosted in loader.  This is used to initialize values in the real KDataStruct.
; (r5) = address of OEMInitGlobals function
;
;-------------------------------------------------------------------------------
        
        LEAF_ENTRY _NKStartup

; Switch to bank 1
        mov     #PR_B1_BK, r0
        ldc     r0, SR                  ; (SR) = kmode, blocked, bank1
        mov     #h'A0000000, r2         ; (r2) = un-cached, un-mapped region base
        mov     #_SHInit, r1
        mov     #_KStack, r15
        or      r2, r15                 ; (r15) = un-cached stack
        or      r2, r1                  ; (r1) = un-cached destination
        
; General SH initialization
        jsr     @r1                     ; SHInit()
        nop

; Switch stack to cached, un-mapped region.
        mov     #_KStack, r15           ; switch to normal kernel stack
        mov     #SH3CTL_BASE, r7        ; (r7_bank1) = ptr to SH3 control registers
        mov     #ExceptionBase, r3      ; (r3_bank1) = kernel exception handlers
        ldc     r3, VBR                 ; switch to kernel's exception handlers
        
; Load new status register
        mov     #PR_B0_IE, r1
        mov     #_KernelInit, r8
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked
        jsr     @r8			; KernelInit()
	nop

; Start thread scheduling
        bra     resched			; start the first thread (call does not return)
        mov     #0, r14                 ; (delay slot) r14 = no current thread
        .endf

        .PAGE

;-------------------------------------------------------------------------------
;
; APICall is the starting of SHx general exception handlers.  It will
; never be invoked directly but indirectly.  All SHx general exceptions 
; except TLBMiss exceptions will be forwarded to the handler defined in 
; the address computed from the sum of VBR, which stores the exception 
; handler base address, and the offset 0x100.  This is exactly where 
; APICall starts as you see ".org	h'100" in the following lines:
;
;-------------------------------------------------------------------------------
        
        LEAF_ENTRY APICall
        
        .PAGE
        
; Bank 1 registers are pre-loaded with the following values:
;
;       (r4) - ptr to current thread
;       (r5) - ptr to context save area
;       (r7) - SH3CTL_BASE (used to access MMU & exception data)

        .org    h'100
; Please note that at this point, SPC will contain the saved PC so does SSR 
; to the saved SR.  Also SR.MD will be set to the previledge mode, SR.BL will 
; be set to disable interrupt, and SR.BR will be set to Bank 1 mode.  Thus 
; a handful of general registers, [r1..r7][_bank1], will be freely available 
; to exception handler right away while [r1..r7][_bank0|_user] will be kept 
; around but only access through LDC instruction. 
;
        mov     @(EXPEVT,r7), r0        ; (r0) = exception code
        mov     #h'e0, r1               ; (r1) = address error load/excecute code
        cmp/eq  r1, r0
; Skip the Syscall process if it is not an address error
        bf/s    geh30                   ; not an address error,
        or      #h'20, r0               ; turn TLB load into 0x60 instead of 0x40

; Address error on load or execute: check if system call. System calls are generated as
; a jump to an odd address at the high end of the address space.

        mov     #FIRST_METHOD, r1
        stc     SPC, r0
        mov     #API_MAX, r3            ; (r3) = lower bound of API addresses
        tst     #1, r0
; Skip the Syscall process and jump to the code which handles other general 
; exceptions.
        bt      geh35                   ; SPC even: not a system call
        cmp/hs  r3, r0                  ; 'T' set iff SPC >= API_MAX
; Skip the Syscall process and jump to the code which handles other general 
; exceptions.
        bf      geh35                   ; address is outside of API range
; Yes, this is a syscall!
        sub     r1, r0
        shar    r0                      ; (r0) = method index
        stc     SSR, r2                 ; (r2) = previous status

        ; jump to the handler
        mov     #SyscallHandler, r1
        jmp     @r1
        nop
        
        .endf

;-------------------------------------------------------------------------------
; The following code is never executed. Its purpose is to support unwinding
; through the call to the exception dispatcher.
;-------------------------------------------------------------------------------

        NESTED_ENTRY GeneralException
        mov.l   r14, @(CtxR14-CtxR8,r14)        ; save R14
        mov.l   r15, @(CtxR15-CtxR8,r14)        ; save stack pointer
        stc     SSR, r1
        mov.l   r1, @(CtxPsr-CtxR8,r14)         ; save processor status
        stc     SPC, r1
        mov.l   r1, @(CtxFir-CtxR8,r14)         ; save original PC
        add     #-CtxR8, r14                    ; (r14) = ptr to
        sts     PR, r1
        mov.l   r1, @(CtxPR,r14)
        add     #-THREAD_CONTEXT_OFFSET, r14
        PROLOG_END

; Non-address error load exeception. Check for TLB Miss due to invalid entry and send
; to the tlb miss handler if necessary.
;
;       (r0) = EXPEVT | 0x20

        .align  4
geh30:  cmp/eq  #h'60, r0
        bf      geh35                   ; not a TLB Miss
        bra     TLBMissHandler
        nop
        .nopool

; General exception or TLB miss which cannot be resolved by the TLB miss handler.

TLBMissError:   ; return here from TLB miss handler if invalid address
geh35:  mov     #_KData+bResched, r1	
        mov.b   @(1,r1), r0             ; (r0) = kernel reentrancy flag
        dt      r0                      ; decrement for each entry
        bf/s    geh33                   ; nested exception
        mov.b   r0, @(1,r1)             ; save reentrancy level

; Handle a general exception that is NOT a system call.
;
;       (r5) = ptr to CtxPSR+4.
;       in register bank 1

        stc     SSR, @-r5               ; save status register
        stc     SPC, @-r5               ; save PC
        mov.l   r15, @-r5               ; save stack pointer
        mov.l   r14, @-r5               ; save register for ptr to current thread
        mov     r4, r14                 ; (r14) = ptr to current thread
        mov     #_KStack, r15           ; switch to kernel stack
geh36:  mov.l   @(EXPEVT,r7), r0        ; (r0) = exception event code
        mov     #h'160, r2
        mov.l   @(MMUTEA,r7), r1        ; (r1) = translation address
        cmp/eq  r0, r2
        bf      geh41                   ; not a TRAPA exception
        bra     geh41
        mov.l   @(TRPA,r7), r1          ; (r1) = trapa value
        .nopool

; A nested exception has occured. Create a temporary thread
; structure on the stack and save the current state into that.
;
;       (r2) = old stack pointer
;       in register bank 1

geh33:  mov     r15, r5                 ; (r5) = ptr to context save area
        add     #h'80-CtxSizeof, r5
        add     #(CtxPsr+4)-h'80, r5 ; (r5) = ptr to PSR save
        stc     SSR, @-r5               ; save status register
        stc     SPC, @-r5               ; save PC
        mov.l   r15, @-r5               ; save stack pointer
        mov.l   r14, @-r5               ; save register for ptr to current thread
        mov     r5, r15
        add     #-CtxR14, r15
        add     #-THREAD_CONTEXT_OFFSET, r15
        mov     r15, r14                ; (r14) = ptr to fake thread
        bra     geh36
        add     #-16, r15               ; make room for argument spill area
        .nopool

; An interrupt has caused a reschedule. Setup the registers for a general
; exception and jump into the context save & exception dispatch.
;
;       (r4) = ptr to current thread
;       (r5) - ptr to context save area
;       (r7) - SH3CTL_BASE (used to access MMU & exception data)
;       cNest == 0 (not inside another exception)
;       in register bank 1

InterruptResched:
        stc     SSR, @-r5               ; save status register
        stc     SPC, @-r5               ; save PC
        mov.l   r15, @-r5               ; save stack pointer
        mov.l   r14, @-r5               ; save register for ptr to current thread ptr
        mov     #0, r0                  ; (r0) = fake EXPEVT value
        mov     #_KStack, r15           ; switch to kernel stack
        mov     r4, r14                 ; (r14) = ptr to current thread

geh41:  mov.l   r13, @-r5
        mov.l   r12, @-r5
        mov.l   r11, @-r5
        mov.l   r10, @-r5
        mov.l   r9, @-r5
        mov.l   r8, @-r5
        stc     r7_user, @-r5
        stc     r6_user, @-r5
        stc     r5_user, @-r5
        stc     r4_user, @-r5
        stc     r3_user, @-r5
        stc     r2_user, @-r5
        stc     r1_user, @-r5
        stc     r0_user, @-r5
        ldc     r1, r6_user             ; (r6) = TEA or TRAPA value (arg2)
        stc     GBR, @-r5
        sts     MACL, @-r5
        mov     #CONTEXT_FULL, r1
        sts     MACH, @-r5
        sts     PR, @-r5
        mov.l   r1, @-r5                ; set context flags
        mov     #PR_B0_IE, r1
        mov     r0, r8                  ; (r8) = exception cause
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked

; Check for interlocked API in progress. The interlocked apis setup the registers
; as follows: (r1) = starting address of sequence, (r2) = ending address of
; sequence, (r3) = (r1) ^ INTRLOCK_KEY.
;
;       (r6) = TEA or TRAPA code (arg2)
;       (r8) = exception cause (from EXPEVT, 0 if interrupt reschedule)
;       (r14) = ptr to current thread
;       in register bank 0.

        mov     #INTERLOCKED_END, r1    ; (r1) = end of interlocked api block
        mov     r14, r9
        add     #THREAD_CONTEXT_OFFSET+CtxR2, r9
        mov.l   @(CtxFir-CtxR2,r9), r5  ; (r5) = resume address
        cmp/hi  r5, r1                  ; 'T' = r1 > r5
        bt      geh70                   ; PC < INTERLOCKED_END

; Dispatch general exception.
;
;       (r6) = TEA or TRAPA code (arg2)
;       (r8) = exception cause
;       (r9) = ptr to CtxR2 in Current Thread's context
;       (r14) = ptr to current thread
;       All user registers saved into thread context
;       in register bank 0

geh45:  tst     r8, r8
        bt      geh55                   ; this is a reschedule request
        mov     #_HandleException, r1
        mov     r8, r5                  ; (r5) = exception cause (arg1)
        jsr     @r1
        mov     r14, r4                 ; (r4) = ptr to current thread (arg0)

        tst     r0,r0
        bt      geh55                   ; must reschedule
        bra     geh60                   ; resume the current thread
        nop
        .nopool

; The current thread is yielding. Save the permanent registers into the
; thread's context structure and invoke NextThread.
;
;       (r14) = ptr to current thread
;       in register bank 0

        .align  4
SaveAndResched:
        mov     r14, r4
        add     #THREAD_CONTEXT_OFFSET, r4; (r4) = ptr to CtxFlags
        mov     #0, r0
        mov.l   r0, @(CtxContextFlags,r4)
        add     #CtxR8, r4              ; (r4) = ptr to CtxR8
        mov.l   r8, @(CtxR8-CtxR8,r4)
        mov.l   r9, @(CtxR9-CtxR8,r4)
        mov.l   r10, @(CtxR10-CtxR8,r4)
        mov.l   r11, @(CtxR11-CtxR8,r4)
        mov.l   r12, @(CtxR12-CtxR8,r4)
        mov.l   r13, @(CtxR13-CtxR8,r4)

; The current thread has been blocked or a reschedule is pending.
; Call the scheduler to obtain the highest priority thread to run.
;
;       (r14) = ptr to current thread
;       register bank unknown

resched:
geh55:  mov     #PR_B0_IE, r1
        mov     #_KData+bResched, r9
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked
        mov     #0, r0                          ; (r0) = 0
        mov.b   r0, @(bProfileOn-bResched,r9)   ; clear profiling bit

renextthread:
        mov.b   @r9, r0
        cmp/eq  #1, r0
        bf      nonextthread

        mov     #_NextThread, r8
        mov     #0, r0
        jsr     @r8
        mov.w   r0, @r9                 ; clear reschedule, still in kernel

nonextthread:
        mov     @(dwKCRes-bResched, r9), r0
        cmp/eq  #1, r0
        bf      nokcresched

        mov     #_KCNextThread, r8
        mov     #0, r0
        jsr     @r8
        mov     r0, @(dwKCRes-bResched, r9)	; clear kcreschedule

        mov     @(dwKCRes-bResched,r9), r0
        cmp/eq  #1, r0
        bt      renextthread

nokcresched:
        mov     #_RunList, r1
        mov     @(4,r1), r0

        cmp/eq  #0, r0
        bt      Idle                    ; no thread to run
        cmp/eq  r0, r14
        bt      geh60                   ; resume current thread

; Switch to a different thread. Update current thread, current process, thread
; local storage data, and process virtual memory context.
;
;       (r0) = ptr to thread to dispatch
;       (r9) = ptr to bResched

        mov     r0, r14                 ; (r14) = ptr to thread

;	Thread switched
        mov     #_SetCPUASID, r5        
        jsr	@r5
        mov	r14, r4                  ; (delay slot) argument to SetCPUASID is the new thread
        
;	Update ptr to current thread, current thread id, and global tls
        mov     #_KData+lpvTls, r6      ; (r6) = &lpvTLS in KPage
        mov.l   r14, @(pCurThd-bResched,r9)     ; save current thread ptr in KPage
        mov.l   @(ThHandle,r14), r0     ; (r0) = thread's handle        
        mov.l   r0, @(hCurThread-lpvTls,r6)     ; save current thread handle in KPage
        mov.l   @(ThTlsPtr,r14), r3     ; (r3) = thread local storage pointer       
        mov.l   r3, @r6                 ; set TLS pointer                           
        ldc     r14, r4_bank            ; (r4_bank1) = ptr to current thread        

; Restore thread state.
;
;       (r14) = ptr to thread structure

geh60:  mov     r14, r7
        add     #THREAD_CONTEXT_OFFSET, r7
        mov     r7, r11
        mov.l   @r7+, r0                ; (r0) = ContextFlags
        lds     @r7+, PR                ; restore return address
        tst     r0, r0
        bt      geh65                   ; only partial restore needed
        lds     @r7+, MACH
        lds     @r7+, MACL
        ldc     @r7+, GBR
        add     #4, r7
        mov.l   @r7+, r1
        mov.l   @r7+, r2
        mov.l   @r7+, r3
        mov.l   @r7+, r4
        mov.l   @r7+, r5
        mov.l   @r7+, r6
        mov.l   @r7, r7

; Reload thread's permanent registers and return value.
;
;       (r11) = ptr to Current Thread's context structure
;       (r13) = ptr to float save area
;       (r14) = ptr to current thread

geh65:  mov.l   @(CtxR8,r11), r8
        mov.l   @(CtxR9,r11), r9
        mov     #PR_B1_BK, r10          ; (r10) = new SR value
        mov.l   @(CtxR0,r11), r0        ; (r0) = return value
        mov     #_KData+bResched, r12
        ldc     r10, SR                 ; (SR) = privileged, bank 1, blocked
        ;++++ now in bank 1 ++++
        mov.w   @r12, r0                ; (r0) = kernel reentrancy flag
        mov.l   @(CtxR10,r11), r10

        cmp/eq  #1, r0
        bt      resched                 ; reschedule required

        shlr8   r0
        add     #1, r0
        mov.b   r0, @(1,r12)            ; save reentrancy level

; if high bit of wPriority is set, profiling should be on, else profiling off
;
;       (r12) = ptr to bResched
;       (r14) = ptr to current thread

        mov.w   @(ThwInfo,r14), r0      ; (r0) = thread's wInfo field
        mov     r11, r5
        shlr16  r0                      ; (r0) = 0xFFFF iff high bit was set
        mov.b   r0, @(bProfileOn-bResched,r12)
        add     #CtxR11, r5             ; (r5) = ptr to CtxR11

        mov.l   @r5+, r11
        mov.l   @r5+, r12
        mov.l   @r5+, r13
        mov.l   @r5+, r14
        mov.l   @r5+, r15               ; restore stack pointer
        ldc     @r5+, SPC
        ldc @r5+, SSR

        rte
        nop
        .nopool

; PC is below the end of the INTERLOCKED APIs, check lower bound and adjust the PC
; to restart the routine.
;
;       (r5) = resume address
;       (r9) = ptr to CtxR2 in Current Thread's context
;       (r14) = ptr to current thread.

geh70:  mov     #INTERLOCKED_START, r1  ; (r1) = start of interlocked api block
        mov     #1, r0
        tst     r0,r5
        bf      geh75                   ; PC is odd, don't change it
        cmp/hi  r5, r1                  ; 'T' = r1 > r5
        bt      geh75                   ; out of range, no backup
        mov     #-8, r1
        and     r1, r5                  ; (old PC) &= ~7

        .aif INTRLOCK_LEDS eq 1
        mov     #h'AA001010, r2         ; (r2) = LED address
        mov.l   @r2, r0
        add     #1,r0
        mov.l   r0, @r2                 ; put it in lights
        .aendi

        mov.l   r5, @(CtxFir-CtxR2,r9)  ; backup PC to start of intrlocked sequence
geh75:  bra     geh45
        nop
        .nopool

; There are no threads which are ready to run. Put the cpu to sleep until
; something is made ready. Since an interrupt may occur between when NextThread
; returns and we get here, the reschedule flag must be checked. To avoid a timing
; race between checking the flag and sleeping, interrupts are blocked but not
; masked before checking the flag. The CPU will acknowledge interrupts regardless
; of the block bit when it is in sleep state.
;
;       (r9) = ptr to bResched

Idle:   mov     #PR_B0_BK, r1
        mov     #_OEMIdle, r8
        ldc     r1, SR                  ; (SR) = privileged, bank 0, exceptions blocked
        mov.b   @r9, r0                 ; (r0) = reschedule flag
        tst     r0, r0
        bf      geh55                   ; reschedule needed, don't sleep

;--------- Work around for SH4 sleep problem. ----------------------------------
        mov     #fInIdle, r0            ; (r0) = &finIdle
        mov.l   #1, r1
        mov.l   r1, @r0                 ; fInIdle = 1
        jsr     @r8                     ; call OEMIdle to sleep
        nop

;--------- Work around for SH4 sleep problem. ----------------------------------
        mov     #fInIdle, r0            ; (r0) = &finIdle
        mov.l   #0, r1
        mov.l   r1, @r0                 ; fInIdle = 0

        mov     #_KData+bResched, r1
        mov     #1, r0
        mov.b   r0, @r1                 ; bResched = 1

        bra     geh55
        nop

        .endf

        .PAGE
        .org    h'400

;-------------------------------------------------------------------------------
; TLB Miss handler
;
; Bank 1 registers are pre-loaded with the following values:
;
;       (r4) - ptr to current thread
;       (r5) - ptr to context save area
;       (r7) - SH3CTL_BASE (used to access MMU & exception data)
;
; Uses: R0, R1, R2, R3, R6
;-------------------------------------------------------------------------------        

        LEAF_ENTRY TLBMissHandler
        
        mov.l   @(MMUTEA,r7), r2        ; (r2) = faulting virtual address
        mov.l   @(MMUTTB,r7), r0        ; (r0) = ptr to current process page dir
        mov     #READWRITE_MASK, r6     ; (r6) == r/w TLB mask
        
; is access for shared heap?
        mov     #VM_SHARED_HEAP_BASE, r1     ; (r1) = shared heap base address
        cmp/hs  r1, r2                  ; 'T' = r2 >= r1
        bf      tlb20                   ; if false, address < VM_SHARED_HEAP_BASE

; in shared heap or kernel address; is the call from kernel mode or user mode?
tlb5:   stc     SSR, r0                 ; (r0) = previous status register
        shlr16  r0                      ; (r0) = old status >> 16
        shlr8   r0                      ; (r0) = old status >> 24        
        and     #h'40, r0               ; (r0) = (r0) AND (kernel mode)
        cmp/eq  #h'40, r0               ; 'T' = r0 == 0x40
        bt      tlb10                   ; if true, this is kernel mode

; call from user mode and address in shared heap or kernel; fail if kernel
        cmp/pz  r2                      ; 'T' = r2 >= 0;
        bf      tlb30                   ; if false, address >2GB, kernel space --> fail
        mov     #READONLY_MASK, r6      ; (r6) == r/o TLB mask
        
; call from user mode and address in shared heap; fail if write
        mov     @(EXPEVT,r7), r0        ; (r0) = exception code
        cmp/eq  #h'40, r0               ; 'T' = r0 == 0x40 (read access)
        bf      tlb30                   ; if false, this is write access --> fail

; kernel address or shared heap address (kernel mode or user mode with read), use kernel page directory
tlb10:	mov	#_g_pprcNK, r0		; (r0) = &g_pprcNK
	mov.l	@r0, r0			; (r0) = g_pprcNK
	mov.l	@(PrcVMBase, r0), r0	; (r0) = &g_pprcNK->ppdir ptr to kernel page dir

; common processing: find the page table corresponding to this VA from page directory
tlb20:	mov	#h'ffc, r3		; (r3) = index mask (to mask off two LS bits at the end and keep the LS ten bits)
        mov     r2, r1			; (r1) = faulting virtual address
	shlr8	r1
	shlr2	r1			; (r1) = VA >> 10 --> idx into page table
	mov	r1, r2			; (r2) = VA >> 10; we will re-use r1 later
	and	r3, r2			; (r2) = DWORD aligned index into page table

	shlr8	r1
	shlr2	r1			; (r1) = VA >> 20 --> idx into page dir.
	and	r3, r1			; (r1) = DWORD aligned index into page directory

; find the page directory entry coresponding to this VA from page directory	
	add	r1, r0			; (r0) = & ppdir->pte[idx]
	mov.l	@r0, r0			; (r0) = pptbl = ppdir->pte[idx]
        cmp/pz  r0                      ; bad page if not kernel address
        bt      tlb30                   ; jump back to general exception handling
	
; find the page table entry coresponding to this VA from page table
	add	r2, r0			; (r0) = &pptbl->pte[idx2]
	mov	@r0, r0			; (r0) = ppage = pptbl->pte[idx2]

; make sure pte entry is valid
        mov     #h'100, r2              ; valid mask is 0x100
        and     r0, r2                  ; (r2) = PTE & valid_mask
        cmp/pl  r2                      ; valid entry = (r2) > 0
        bf      tlb30                   ; invalid entry (valid bit not set); jump to general exception

; store the pfn entry into TLB
        and     r6, r0                  ; (r6) = r/w or r/o TLB mask

; set the assistance bits in MMUPTEA register used in PCMCIA access
; assistance bits are set as bit[9] of PTEL goes to TC bit of MMUPTEA
; and bit[29]...bit[31] of PTEL map to SA bits of MMUPTEA register
        mov.l   r0, r1
        mov     #-9, r3
        shld    r3, r1
        mov     #1, r3
        tst     r3, r1
        mov     #-20, r3
        shld    r3, r1
        bt      tlb40a
        add     #8, r1
tlb40a:
        mov.l   r1, @(MMUPTEA,r7)       ; set assistance part of TLB entry
        mov.l   r0, @(MMUPTEL,r7)       ; set lower part of TLB entry        
        ldtlb
        nop
        nop  

  .aif NKPROF eq h'01
        ;
        ; Update the TLBMiss counter for CELOG
        ;
        mov     #_KData+dwTlbMissCnt, r2
        mov.l   @r2, r1			; (r1) = dwTlbMissCnt
        add     #1, r1			; r1++
        mov.l   r1, @r2			; dwTlbMissCnt += 1
  .aendi
        
	rte
        nop
        .nopool

tlb30:  bra    TLBMissError
        nop
        .nopool       

        .PAGE
        ALTERNATE_ENTRY _LoadKPage
; Load User KPage entry into TLB.       
        mov     #KPAGE_PTEL, r1
        mov     #SH3CTL_BASE, r3
        mov     @(MMUPTEH,r3), r0       ; (r0) = ASID in LSByte
        mov     #USER_KPAGE, r4
        and     #h'FF, r0               ; (r0) = ASID
        or      r4, r0                  ; (r0) = User KPage | ASID
        shll    r1
        mov.l   r0, @(MMUPTEH,r3)
        shlr    r1                      ; clear hit bit of entry
        mov.l   r1, @(MMUPTEL,r3)
        ldtlb
        nop
        nop
        rts
        nop
        .nopool
        .endf

        .PAGE

;-------------------------------------------------------------------------------
;
; void ZeroPage(void *vpPage)
;
; Entry   (r4) = (vpPage) = ptr to address of page to zero
; Return  none
; Uses    r0, r1, r4
;
;-------------------------------------------------------------------------------        
        
        LEAF_ENTRY _ZeroPage

        mov     #1 << (VA_PAGE-4), r1   ; (r1) = # of 16 bytes units to zero
        mov     #0, r0
zp10:   mov.l   r0, @r4
        mov.l   r0, @(4,r4)
        mov.l   r0, @(8,r4)
        mov.l   r0, @(12,r4)
        dt      r1                      ; (r1) = # of units left
        bf/s    zp10
        add     #16, r4                 ; (r4) = next 16 byte unit
        rts
        nop
        .endf

        .PAGE   

;-------------------------------------------------------------------------------
; NOP
;-------------------------------------------------------------------------------        

        LEAF_ENTRY _UnusedHandler
        rts
        mov     #SYSINTR_NOP, r0        ; ignore the interrupt
        .endf

        .PAGE
        .org    h'600

;-------------------------------------------------------------------------------
;
; An interrupt exception has occured. Dispatch to an interrupt handler based
; upon the higest unmasked pending interrupt bit which is set.
;
; Bank 1 registers are pre-loaded with the following values:
;
;       (r4) - ptr to current thread
;       (r5) - ptr to context save area
;       (r7) - SH3CTL_BASE (used to access MMU & exception data)
;
;-------------------------------------------------------------------------------        
        
        LEAF_ENTRY InterruptExceptionHandler
        mov.l   @(INTEVT,r7), r6
        
        mov     #_ExceptionTable, r0
        mov     r6, r2
        shlr2   r2
        shlr    r2                      ; (r2) = exception code >> 3
        mov.l   @(r0,r2), r1            ; (r1) = interrupt handler function
        
        shlr2   r2
        mov     #_IntrPrio, r0
        add     #-16, r2
        mov.b   @(r0,r2), r3

        mov     #_KData+bResched, r2
        mov.b   @(1,r2), r0             ; (r0) = kernel reentrancy flag
        dt      r0                      ; decrement for each entry
        bf/s    ieh01                   ; nested exception
        mov.b   r0, @(1,r2)             ; save reentrancy level
        mov     r15, r2
        mov     #_KStack, r15           ; switch to kernel's stack
        mov.l   r2, @-r15               ; save stack pointer
ieh01:

;--------- Work around for SH4 sleep problem. ----------------------------------
;       The problem is that it doesn't turns on interrupt and go to sleep atomically.
;       If an interrupt occurs in OEMIdle, the sleep instruciton will turn on interrupt,
;       and the ISR will be called before the CPU goes to sleep. So the interrupt will
;       not be serviced until the next interrupt.
;       (r0) and (r2) are free to use
;
        ; are we in idle?
        mov.l   #fInIdle, r0            ; (r0) = &fInIdle
        mov.l   @r0, r0                 ; (r0) = fInIdle
        cmp/eq  #0, r0                  ; in idle?
        bt      ieh001                  ; normal processing if not

        ;
        ; We're in Idle. If SPC is at the "sleep" instruction, increment it by 2
        ;
        stc     SPC, r2                 ; (r2) = interrupt return address
        mov.w   @r2, r0                 ; (r0) = instruction at the address
        cmp/eq  #h'001b, r0             ; is this a "sleep" instruction?
        bf      ieh001                  ; normal processing if not

        ;
        ; We're right at sleep instruction, increment SPC
        ;
        add     #2, r2                  ; increment the return address
        ldc     r2, SPC      
ieh001:

;--------- End work around ------------------------

        ; go to bank 0, interrupt disabled
        mov     #PR_B0_BK, r2
        ldc     r2, SR

        ;
        ; on bank 0, interrupt disabled
        ;   (r1_bank) = ISR to call
        ;   (r3_bank) = ISR prio (from IntrPrio)
        ;

        ; save all volatile registers
        sts     PR,     @-r15
        stc     SPC,    @-r15
        stc     SSR,    @-r15
        sts     macl,   @-r15
        sts     mach,   @-r15
        stc     GBR,    @-r15
        mov.l   r0,     @-r15               ; save registers
        mov.l   r1,     @-r15               ; save registers
        mov.l   r2,     @-r15               ; save registers
        mov.l   r3,     @-r15               ; save registers
        mov.l   r4,     @-r15               ; save registers
        mov.l   r5,     @-r15               ; save registers
        mov.l   r6,     @-r15               ; save registers
        mov.l   r7,     @-r15               ; save registers

        ; reserve space for 4 registers on stack (C calling convention)
        ; reserve space to save off at-most two bank1 registers
        add.l   #-24,   r15

        stc     r1_bank, r1                ; (r1) = ISR to call
        stc     r3_bank, r3                ; (r3) = ISR prio

  .aif NKPROF eq h'01
        ;
        ; On profiling builds, log the ISR entry event to CeLog
        ;

        ; save off the bank 1 registers
        mov.l   r1, @(4*REGSIZE, r15)   ; (stack+4) = ISR to call
        mov.l   r3, @(5*REGSIZE, r15)   ; (stack+5) = ISR prio

        ; bank 0, interrupts masked
        mov     #PR_B0_IM, r2           ; (r2) = new status
        ldc     r2, SR                  ; (SR) = bank 0, interrupts masked 

        ; call the celog function
        mov     #_CELOG_Interrupt, r1   ; (r1) = celog function
        mov     #h'80000000, r4         ; (delay slot) r4 = mark as ISR entry
        jsr     @r1                     ; CELOG_Interrupt(dwLogValue)
        nop
        
        ; bank 0, interrupts disabled
        mov     #PR_B0_BK, r2           ; (r2) = new status
        ldc     r2, SR                  ; (SR) = bank 0, interrupts disabled

        ; restore the bank 1 registers
        mov.l   @(4*REGSIZE, r15), r1   ; (r1) = ISR to call
        mov.l   @(5*REGSIZE, r15), r3   ; (r3) = ISR prio
        ldc     r1, r1_bank             ; (r1_bank) = ISR to call
        ldc     r3, r3_bank             ; (r3_bank) = ISR prio
        
  .aendi

        mov     #PR_B0_IE, r2           ; (r2) = bank 0, int enabled

        shll2   r3                      ; (r3) = int mask << 2
        shll2   r3                      ; (r3) = int mask << 4
        or      r3, r2                  ; (r2) = (curr int mask) | (r3)

        ; bank 0, lower prio masked
        ldc     r2, SR                  ; (SR) = bank 0, lower prio interrupts masked

        jsr     @r1                     ; invoke interrupt service routine
        nop

        ; call the ISR hook (pfnOEMIntrOccurs is set to a faked function if not changed by OEM)
        mov     #_OEMNotifyIntrOccurs, r3
        jsr     @r3                     ; call the hook
        mov     r0, r4                  ; (delay slot) (r4) = SYSINTR returned == argument to pfnOEMIntrOccurs

        ; bank 0, exceptions blocked
        mov     #PR_B0_BK, r2           ; (r2) = new status
        ldc     r2, SR                  ; (SR) = bank 0, interrupts disabled
        
  .aif NKPROF eq h'01
        ;
        ; On profiling builds, log the ISR exit event to CeLog
        ;
        
        ;
        mov     #_KData+cNest, r1
        mov.b   @r1, r1                 ; r1 = nest level (0, -1, -2, etc)
        neg     r1, r1                  ; r1 = nest level (0,  1,  2, etc)
        shll16  r1                      ; r1 <<= 16

        ; save off the sysintr value
        mov.l   r0, @(4*REGSIZE, r15)   ; (stack+4) = r0 = sysintr value

        ; bank 0, interrupts masked (to enable tlb miss handling in celog)
        mov     #PR_B0_IM, r3           ; (r3) = new status
        ldc     r3, SR                  ; (SR) =  bank0, interrupts masked

        mov     #_CELOG_Interrupt, r2   ; (r2) = celog function
        mov     r0, r4                  ; (r4) = SYSINTR value
        jsr     @r2                     ; CELOG_Interrupt(dwLogValue)
        or      r1, r4                  ; (delay slot) r4 = (-cNest << 16) | SYSINTR_val

        ; bank 0, interrupts disabled
        mov     #PR_B0_BK, r2           ; (r2) = new status
        ldc     r2, SR                  ; (SR) = bank 0, interrupts disabled

        ; restore the sysintr value
        mov.l   @(4*REGSIZE, r15), r0   ; (r0) = sysintr value
        
  .aendi

        ; (r3_bank) = sysintr value
        ldc     r0, r3_bank             ; (r3_bank) = sysintr value

        ; bank 1, exceptions blocked
        mov     #PR_B1_BK, r2
        ldc     r2, SR

        ; restore all user registers
        add.l   #24,   r15

        ldc     @r15+,  r7_user
        ldc     @r15+,  r6_user
        ldc     @r15+,  r5_user
        ldc     @r15+,  r4_user
        ldc     @r15+,  r3_user
        ldc     @r15+,  r2_user
        ldc     @r15+,  r1_user
        ldc     @r15+,  r0_user
        ldc     @r15+,  GBR
        lds     @r15+,  mach
        lds     @r15+,  macl
        ldc     @r15+,  SSR
        ldc     @r15+,  SPC
        lds     @r15+,  PR

        ; (r3) = sysintr value
        mov     #_KData+bResched, r2
        mov.b   @(1,r2), r0
        add     #1, r0
        mov.b   r0, @(1,r2)
        cmp/eq  #1, r0
        bf      ieh02
        mov     @r15, r15
ieh02:
        mov     r3, r0

        mov     #SH3CTL_BASE, r7
        cmp/eq  #SYSINTR_NOP, r0
        bt      ieh48                   ; no additional processing needed
        cmp/eq  #SYSINTR_BREAK, r0
        bt      ieh60                   ; external break button pushed
        add     #-SYSINTR_DEVICES, r0
        cmp/pz  r0
        bf      ieh40

        ; valid SYSINTR
        mov     #32, r3                         ; r3 = 32
        mov     #_KData+PendEvents1, r1         ; r1 = &PendEvents1
        cmp/hs  r3, r0                          ; 'T' = (r0 >= 32)
        bt/s    ieh45                           ; go handle ISR# >= 32 if true
        mov     #1, r3                          ; (delay slot), (r3) =1
        
        mov.l   @r1, r2                         ; r2 = PendEvents1
        shld    r0, r3                          ; r3 = bit signifying current interrupt
        or      r3, r2                          ; r2 = all interrupts so far (bitmask)
        mov.l   r2, @r1                         ; store PendEvents1
ieh40:  mov     #_KData+bResched, r1
        mov.b   @(1,r1), r0                     ; cNest
        mov     #1, r2
        cmp/eq  #1, r0
        bf      ieh49
        bra     InterruptResched                ; jump to general exception handler
        mov.w   r2, @r1

        .nopool

ieh45:  add     #-32, r0                        ; ISR# -= 32
        mov.l   @(4, r1), r2                    ; r2 = PendEvents2
        shld    r0, r3                          ; r3 = bit signifying current interrupt
        or      r3, r2                          ; r2 = all interrupts so far (bitmask)
        bra     ieh40
        mov.l   r2, @(4, r1)                    ; (delay slot) store PendEvents2
        
        .nopool

; Check for bResched set by nested interrupt
ieh48:  mov     #_KData+bResched, r1
        mov     #0x0101, r2
        mov.w   @r1, r0         ; r0 = cNest << 8 + bResched
        cmp/eq  r0, r2          ; if((cNest ==1)&&(bResched ==1))
        bf      ieh50           ;    do rescheduling
        mov     #1, r2
        bra     InterruptResched
        mov.w   r2, @r1
        .nopool

; Check for interlocked API in progress. The interlocked apis are all located
; at the end of the user kernel page. If the PC is less than INTERLOCKED_END and
; greater than INTERLOCKED_START, then the PC is adjusted to restart the routine.
;
;       in register bank 1.

ieh49:  mov.b   r2, @r1                 ; set bResched flag
ieh50:  mov     #INTERLOCKED_END, r1    ; (r1) = end of interlocked api block
        stc     SPC, r0                 ; (r0) = interrupted PC
        cmp/hi  r0, r1                  ; 'T' = r1 > r0
        bt      ieh70                   ; PC < INTERLOCKED_END
ieh55:  rte
        nop
        .nopool

; External break button. Trap into the debugger.

ieh60:  mov     #16, r0
        mov     r0, @(TRPA,r7)          ; set trapa code to 16 (trapa #4)
        mov     #h'160, r0              ; (r0) = trapa expevt value
        bra     TLBMissError
        mov     r0, @(EXPEVT,r7)        ; set event code
        .nopool

; PC is below the end of the INTERLOCKED APIs, check lower bound and adjust the PC
; to restart the routine.
;
;       (r0) = interrupted PC

ieh70:  mov     #INTERLOCKED_START, r1  ; (r1) = start of interlocked api block
        tst     #1,r0
        bf      ieh55                   ; PC is odd, don't change it
        cmp/hi  r0, r1                  ; 'T' = r1 > r0
        bt      ieh55                   ; out of range, no backup
        mov     #-8, r1
        and     r1, r0                  ; (old PC) &= ~7
        ldc     r0, SPC                 ; update PC

        .aif INTRLOCK_LEDS eq 1
        mov     #h'AA001010, r2         ; (r2) = LED address
        mov.l   @r2, r0
        add     #1,r0
        mov.l   r0, @r2                 ; put it in lights
        .aendi
        rte
        nop

        .endf

_ExceptionBaseAddress   .data.l ExceptionBase
_ExceptionEndAddress    .data.l xKCall          ; The value must be right after all the 
                                                ; exception handlers. The value must be
                                                ; updated if we move xKCall for any reason.

        .global _ExceptionBaseAddress
        .global _ExceptionEndAddress

;-------------------------------------------------------------------------------
; The following code is never executed. Its purpose is to support unwinding
; through the call to the exception dispatcher.
;-------------------------------------------------------------------------------        

        NESTED_ENTRY xKCall
        mov.l   r15, @(0,r15)           ; caller's stack pointer
        sts.l   PR, @-r15               ; return address
        add     #-16, r15               ; argument save area
        PROLOG_END

;-------------------------------------------------------------------------------
; KCall - call kernel function
;
;       KCall invokes a kernel function in a non-preemtable state by incrementing
; the kernel nest level and switching onto a kernel stack.
;
;       While in a preemtible state, the thread's register save area is
; volatile. On the way in, nothing can be saved into the thread
; structure until KNest is set and on the way out anything needed from the
; thread structure must be loaded before restoring KNest.
;
;       The sequence of stack switching must be handled carefully because
; whenever KNest != 1, the general exception handler assumes that the kernel
; stack is current and will not switch stacks. On the way in, we must switch
; to the kernel stack before setting KNest but not use it until after KNest
; is set.  On the way out, we must reset KNest before restoring the thread's
; stack pointer.
;
;       Entry   (r4) = ptr to function to call
;               (r5) = first function arg
;               (r6) = second fucntion arg
;               (r7) = third function arg
;       Exit    (r0) = function return value
;       Uses    r0-r7
;-------------------------------------------------------------------------------        

        ALTERNATE_ENTRY _KCall

        mov     #_KData+bResched, r1
        mov     r4, r3                  ; (r3) = ptr to function to call
        mov.b   @(1,r1), r0             ; (r0) = kernel nest level
        mov     r5, r4                  ; ripple args down
        mov     r6, r5
        dt      r0
        bf/s    kc50                    ; already in non-preemtible state
        mov     r7, r6

; Entering non-preemptible state. We must switch onto the kernel stack
; before setting KNest in case an interrupt occurs during the switch.

        mov     r15, r2                 ; (r2) = original stack pointer
        mov     #_KStack, r15           ; switch to kernel stack
        mov.b   r0, @(1,r1)             ; enter non-preemtible state (KNest = 0)
        sts     PR, r0
        mov.l   r2, @(20,r15)           ; save thread's stack pointer
        jsr     @r3                     ; invoke non-preemtible function
        mov.l   r0, @(16,r15)           ; save return address

; Function complete. Return to preemtible state then check if a reschedule
; is needed.

        mov     #_KData+bResched, r1
        mov     r0, r3                  ; (r3) = function return value
        mov.l   @(16,r15), r2           ; (r2) = return address
        mov.l   @(20,r15), r5           ; (r5) = original stack pointer
        mov     #PR_B0_IM, r7           ; (r7) = new status: bank 0, exceptions enabled, interrupts masked
        stc     SR, r6                  ; (r6) = old status
        ldc     r7, SR                  ; mask all interrtupts

        mov.b   @r1, r0                 ; (r0) = reschedule flag
        lds     r2, pr
        cmp/eq  #1, r0
        bt      kc20                    ; reschedule required.

        mov     @(dwKCRes-bResched,r1), r0
        cmp/eq  #1, r0
        bt      kc20

        mov     #1, r0
        mov.b   r0, @(1,r1)             ; leave non-preemtible state
        mov     r3, r0                  ; (r0) = function return value
        ldc     r6, SR                  ; restore interrupt mask state
        rts
        mov     r5, r15                 ; restore stack pointer
        .nopool


; ReschedFlag set, so must run the scheduler to find which thread
; to dispatch next.
;
;       (r1) = ptr to bResched in KPage
;       (r2) = return address
;       (r3) = KCall return value
;       (r5) = original stack pointer
;       (r6) = old status register value

kc20:   ldc     r6, SR                  ; restore interrupt mask state
        mov.l   @(pCurThd-bResched, r1), r4     ; (r4) = ptr to current THREAD
        mov     r4, r1
        add     #THREAD_CONTEXT_OFFSET, r1      ; (r1) = ptr to thread's register context
        mov.l   r3, @(CtxR0, r1)        ; save return value
        add     #CtxR8, r1              ; (r1) = ptr to thread's R8
        mov     #PR_B0_IE, r3           ; (r3) = kernel mode PSR
        mov.l   r2, @(CtxFir-CtxR8, r1) ; thread resumes at the return address
        mov.l   r3, @(CtxPsr-CtxR8, r1) ;   & in kernel mode.
        mov.l   r14, @(CtxR14-CtxR8, r1); save thread's R14
        mov.l   r5, @(CtxR15-CtxR8, r1) ; save thread's stack pointer
        bra     SaveAndResched
        mov     r4, r14                 ; (r14) = ptr to current THREAD

kc25:   bra     resched
        mov     #0, r14                 ; no current thread

; Nested KCall. Just invoke the function directly.
;
;       (r3) = function address
;       (r4) = 1st function argument
;       (r5) = 2nd function argument
;       (r6) = 3rd function argument

kc50:   jmp     @r3
        nop

        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------        

        LEAF_ENTRY _GetAndClearFloatCode
        sts.l   fpscr, r1
        mov     r1, r0
        mov     #h'3f000, r2
        and     r2, r0
        not     r2, r2
        and     r2, r1
        lds     r1, fpscr
        shlr8   r0
        shlr2   r0
        shlr2   r0
        rts
        nop

        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------        

        LEAF_ENTRY _GetCauseFloatCode
        sts.l   fpscr, r0
        mov     #h'3f000, r2
        and     r2, r0
        shlr8   r0
        shlr2   r0
        rts
        shlr2   r0

        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _DisableFPU
        stc     SR, r0
        mov     #h'00008000, r1
        or      r0, r1
        ldc     r1, SR
        rts
        nop
        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _SaveFloatContext
        stc     SR, r0
        mov     #h'ffff7fff, r1
        and     r0, r1
        ldc     r1, SR  
        add     #THREAD_CONTEXT_OFFSET, r4
        add     #CtxFpul+4, r4
        sts.l   fpul, @-r4
        sts.l   fpscr, @-r4
        add     #(4*16)+8, r4   ; (r4) = ptr to end of CtxFRegs
        add     #(4*16), r4     ; (r4) = ptr to end of CtxXFregs
        mov     #0, r1
        lds     r1, fpscr
        .data.w h'FBFD          ; frchg instr.
        fmov.s  fr15, @-r4
        fmov.s  fr14, @-r4
        fmov.s  fr13, @-r4
        fmov.s  fr12, @-r4
        fmov.s  fr11, @-r4
        fmov.s  fr10, @-r4
        fmov.s  fr9, @-r4
        fmov.s  fr8, @-r4
        fmov.s  fr7, @-r4
        fmov.s  fr6, @-r4
        fmov.s  fr5, @-r4
        fmov.s  fr4, @-r4
        fmov.s  fr3, @-r4
        fmov.s  fr2, @-r4
        fmov.s  fr1, @-r4
        fmov.s  fr0, @-r4
        .data.w h'FBFD          ; frchg instr.
        fmov.s  fr15, @-r4
        fmov.s  fr14, @-r4
        fmov.s  fr13, @-r4
        fmov.s  fr12, @-r4
        fmov.s  fr11, @-r4
        fmov.s  fr10, @-r4
        fmov.s  fr9, @-r4
        fmov.s  fr8, @-r4
        fmov.s  fr7, @-r4
        fmov.s  fr6, @-r4
        fmov.s  fr5, @-r4
        fmov.s  fr4, @-r4
        fmov.s  fr3, @-r4
        fmov.s  fr2, @-r4
        fmov.s  fr1, @-r4
        fmov.s  fr0, @-r4
        ldc     r0, SR  
        rts
        nop
        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _RestoreFloatContext
        stc     SR, r0
        mov     #h'ffff7fff, r1
        and     r0, r1
        ldc     r1, SR
        add     #THREAD_CONTEXT_OFFSET, r4
        add     #CtxFpscr, r4
        mov.l   @r4+, r2                ; (r2) = new value for FPSCR
        mov.l   @r4+, r3                ; (r3) = new value for FPUL
        mov     #0, r1
        lds     r1, fpscr
        fmov.s  @r4+, fr0
        fmov.s  @r4+, fr1
        fmov.s  @r4+, fr2
        fmov.s  @r4+, fr3
        fmov.s  @r4+, fr4
        fmov.s  @r4+, fr5
        fmov.s  @r4+, fr6
        fmov.s  @r4+, fr7
        fmov.s  @r4+, fr8
        fmov.s  @r4+, fr9
        fmov.s  @r4+, fr10
        fmov.s  @r4+, fr11
        fmov.s  @r4+, fr12
        fmov.s  @r4+, fr13
        fmov.s  @r4+, fr14
        fmov.s  @r4+, fr15
        .data.w h'FBFD          ; frchg instr.
        fmov.s  @r4+, fr0
        fmov.s  @r4+, fr1
        fmov.s  @r4+, fr2
        fmov.s  @r4+, fr3
        fmov.s  @r4+, fr4
        fmov.s  @r4+, fr5
        fmov.s  @r4+, fr6
        fmov.s  @r4+, fr7
        fmov.s  @r4+, fr8
        fmov.s  @r4+, fr9
        fmov.s  @r4+, fr10
        fmov.s  @r4+, fr11
        fmov.s  @r4+, fr12
        fmov.s  @r4+, fr13
        fmov.s  @r4+, fr14
        fmov.s  @r4+, fr15
        lds     r2, fpscr
        lds     r3, fpul
        ldc     r0, SR  
        rts
        nop
        .endf

        .PAGE

;-------------------------------------------------------------------------------
; This code is copied to the kernel's data page so that it is accessible from
; the kernel & user code. The kernel checks if it is interrupting an interlocked
; api by range checking the PC to be between UserKPage+0x380 & UserKPage+0x400.
; The routines are organized such that they can be restarted by masking off the
; lower 3 bits of the PC. Each routine is at most 4 instructions with the store
; instruction as the last instruction in the 4 inst. block.
;-------------------------------------------------------------------------------
        
        .align  8
        LEAF_ENTRY _InterlockedAPIs
ILMaskByte:
        mov.b   @r4, r0                 ; (r0) = original byte value
        and     r5, r0                  ; clear some bits
        or      r6, r0                  ; set some bits
        mov.b   r0, @r4                 ; update byte value
        rts
        nop

        .align 8
ILPopList:
        mov.l   @r4, r0                 ; (r0) = ptr to item at head
        nop
        tst     r0, r0
        bf      popx                    ; list is not empty
        rts
        nop
        .align  8
        bra     ILPopList		; restart from popx: due to interrupt comes here
        nop
popx:   mov.l   @r0, r1
        mov.l   r1, @r4
        rts
        nop

        .align  8
ILPushList:
        mov.l   @r4, r0                 ; (r0) = old head of list
        nop
        mov.l   r0, @r5                 ; store linkage
        mov.l   r5, @r4                 ; store new list head
        rts
        nop

        .align  8
ILExchange:
        mov.l   @r4, r0                 ; (r0) = original contents
        nop
        nop
        mov.l   r5, @r4                 ; store new contents
        rts
        nop

        .align  8
ILCmpExchange:
        mov.l   @r4, r0                 ; (r0) = original contents
        cmp/eq  r0, r6
        bf      ICExEnd                 ; no match, skip store
        mov.l   r5, @r4                 ; store new contents
ICExEnd: rts
        nop

        .align  8
ILIncrement:
        mov.l   @r4, r0                 ; (r0) = original contents
        nop                             ; load delay + align end label
        add     #1, r0
        mov.l   r0, @r4                 ; store new contents
        rts
        nop

        .align  8
; NOTE: Must not damage R3 which may contain the saved return address from
;       an InterlockedDecrement call!
ILXAdd:
        mov.l   @r4, r0                 ; (r0) = original contents
        mov     r5, r1                  ; (r1) = increment value
        add     r0, r1
        mov.l   r1, @r4                 ; store new contents
        rts
        nop
        .align  8
        .export _InterlockedEnd
_InterlockedEnd:
        .endf

;-------------------------------------------------------------------------------
; CaptureContext is invoked in kernel context on the user thread's stack to
; build a context structure to be used for exception unwinding.
;
;       (r15) = aligned stack pointer
;       (r0-r14), etc. - CPU state at the time of exception
;-------------------------------------------------------------------------------

        LEAF_ENTRY _CaptureContext
; make room for context record and exception record        
        add     #-ExrSizeof, r15        ; room for Exception Record
        add     #h'80-CtxSizeof, r15    ; room for Context
        add     #CtxR15-h'80, r15

;
; save all the registers, (r15) = &pCtx->R15
;
        mov.l   r15, @(0,r15)           ; for the unwinder (updated by EXceptionDispatch)
        mov.l   r14, @-r15
        stc     SPC, r14
        mov.l   r14, @(CtxFir-CtxR14,r15) ; for unwinding (updated by ExceptionDispatch)
        stc     SSR, r14
        mov.l   r14, @(CtxPsr-CtxR14,r15)
        mov.l   r13, @-r15
        mov.l   r12, @-r15
        mov.l   r11, @-r15
        mov.l   r10, @-r15
        mov.l   r9, @-r15
        mov.l   r8, @-r15
        mov.l   r7, @-r15
        mov.l   r6, @-r15
        mov.l   r5, @-r15
        mov.l   r4, @-r15
        mov.l   r3, @-r15
        mov.l   r2, @-r15
        mov.l   r1, @-r15
        mov.l   r0, @-r15
        stc     GBR, r2
        mov.l   r2, @-r15
        sts     MACL, r2
        mov.l   r2, @-r15
        mov     #CONTEXT_FULL, r1
        sts     MACH, r2
        mov.l   r2, @-r15
        sts     PR, @-r15
        mov     r15, r14                ; (r14) = ptr to context.PR
        
        mov.l   r1, @-r15               ; set context flags
        mov     #_ExceptionDispatch, r0
        mov     #CtxSizeof, r4          ;
        extu.b  r4, r4                  ; (r4) = sizeof (CONTEXT)
        mov     r4, r8                  ; (r8) = sizeof (CONTEXT) -- saving off incase we need to run SEH
        mov     r15, r5                 ; (r5) = arg2 = ptr to context structure = pCtx
        add     r5, r4                  ; (r4) = arg1 = (r5) + sizeof(CONTEXT) = pExr
;
; save pCtx and pExr in non-volatile register, in case we need to run SEH
;
        mov     r5, r9                  ; (r9) = pCtx
        
        jsr     @r0
        add     #-16, r15               ; (delay slot) allocate argument save area

        tst     r0, r0                  ; fRunSEH?
        bf      RunSEH

;
; Not running SEH, resume from context
;

; Reload updated context and resume thread execution.
;       (r14) = ptr to context.PR
        lds     @r14+, PR
        lds     @r14+, MACH
        lds     @r14+, MACL
        ldc     @r14+, GBR
        mov.l   @r14+, r0
        mov.l   @r14+, r1
        mov.l   @r14+, r2
        mov.l   @r14+, r3
        mov.l   @r14+, r4
        mov.l   @r14+, r5
        mov.l   @r14+, r6
        mov.l   @r14+, r7
        mov.l   @r14+, r8
        mov.l   @r14+, r9
        mov.l   @r14+, r10

;
; bank 0, exceptions enabled, interrupts masked
;
        mov     #PR_B0_IM, r15              
        ldc     r15, SR                         ; 
;
; exceptions enabled but interrupts masked from this point on, until rte is executed
;

; handle fpu
        mov     #_KData+g_CurFPUOwner, r12
        mov     @r12, r12                       ; (r12) = g_pCurFPUOwner
        stc     r4_user, r13                    ; (r13) = pCurThread
        cmp/eq  r12, r13
        mov     #h'0, r12
        bt      cc2
        mov     #h'8000, r12
        
cc2:
;       (r12) = 0 if not FPU Owner
;             = 0x8000 if FPU owner

        mov.l   @r14+, r11                      ; restore r11
        mov     @(CtxFir-CtxR12,r14), r13       ; (r13) = target Fir
        mov     @(CtxPsr-CtxR12,r14), r15       ; (r15) = target SR
        or      r12, r15                        ; enable FPU if we're the owner
        mov.l   @r14+, r12                      ; restore r12

; Reload final state with exceptions disabled.
;
;       (r13) = thread's Fir
;       (r14) = thread's SR
;       (r15) = ptr to Context.R13

        ldc     r13, SPC                        ; (SPC) = target Fir
        mov.l   @r14+, r13                      ; restore r13

        ldc     r15, SSR                        ; (SSR) = traget SR

        mov.l   @(4,r14), r15                   ; restore r15
        mov.l   @r14, r14                       ; restore r14

        rte
        nop
        
RunSEH:
;       (r8) = sizeof (CONTEXT)
;       (r9) = pCtx == target SP if run SEH in k-mode
;

        mov     #_g_pfnKrnRtlDispExcp, r10      ; (r10) = addr of kernel mode exception dispatch
        mov     r9, r0
        add     #CtxR8, r0                      ; (r0) = &pCtx->R8
        mov.l   @(CtxPsr-CtxR8, r0), r11        ; (r11) = target SR
;
;       figure out context mode
;
        mov     r11, r2
        shlr16  r2
        shlr8   r2                              ; (r2) = pCtx->SR >> 24

        mov     #h'40, r1                       ; h'40 = KERNEL_MODE
        and     r1, r2                          ; (r2) = mode to run SEH on
        cmp/eq  r2, r1
        bt      CallSEH                         ; (r1) == (r2) if kmode
;
;   user-mode, update pExr, pCtx, and pfnRtlDispatchException
;
        mov     #_g_pfnUsrRtlDispExcp, r10      ; (r10) = addr of user mode exception dispatch
        mov.l   @(CtxR15-CtxR8, r0), r9         ; (r9)  = pCtx->R15 == target SP
        
CallSEH:
;
;       (r8) = sizeof (CONTEXT)
;       (r9)  = target SP == pCtx
;       (r10) = &RtlDispathcException (user or kernel mode)
;       (r11) = target SR
;
        mov.l   @r10, r10                       ; (r10) = RtlDispatchException
        mov     r9, r5                          ; (r5) = arg2 = pCtx 
        mov     r8, r4
        add     r5, r4                          ; (r4) = arg1 = pExr = pCtx + sizeof(CONTEXT)
        
        mov     #h'8000, r1                     ; (r1) = fpu enable bit
        mov     #_KData+g_CurFPUOwner, r2
        stc     r4_user, r3                     ; (r3) = pCurThread
;
; bank 0, exceptions enabled, interrupts masked
;
        mov     #PR_B0_IM, r6             
        ldc     r6, SR                          ; 

; handle fpu
        mov     @r2, r2                         ; (r2) = g_pCurFPUOwner
        cmp/eq  r2, r3
        bf      done_fpu
        or      r1, r11                         ; (r11) = target SR | FPU_ENABLE
done_fpu:

        mov     r9, r15                         ; (r15) = (target sp)
        ldc     r10, SPC                        ; (SPC) = target Fir
        ldc     r11, SSR                        ; (SSR) = traget SR
        add     #-16, r15                       ; (delay slot) sp -= 16, per C calling convertion

        rte
        nop
        
        .endf

        .PAGE

;-------------------------------------------------------------------------------
; RtlCaptureContext is invoked in kernel context on the user thread's stack to
; build a limited context structure to be used for exception unwinding.
;
;       (r4) = ptr to CONTEXT
;-------------------------------------------------------------------------------
        LEAF_ENTRY _RtlCaptureContext


        mov.l   r10, @(CtxR10,r4)
        mov     #CtxPsr, r10
        add     r4,r10
        sts.l   PR, @-r10  ;;Store RA as Fir to remove this frame
        mov.l   r15, @-r10
        mov.l   r14, @-r10
        mov.l   r13, @-r10
        mov.l   r12, @-r10
        mov.l   r11, @-r10
        add.l   #-4, r10  ;;Gets rid of r10's space
        mov.l   r9, @-r10
        mov.l   r8, @-r10
        mov.l   r7, @-r10
        mov.l   r6, @-r10
        mov.l   r5, @-r10
        mov.l   r4, @-r10
        mov.l   r3, @-r10
        mov.l   r2, @-r10
        mov.l   r1, @-r10
        mov.l   r0, @-r10
        stc.l   GBR, @-r10
        sts.l   MACL, @-r10
        sts.l   MACH, @-r10
        sts.l   PR, @-r10
        mov     #CONTEXT_FULL, r10
        mov.l   r10,@r4
        rts
        mov.l   @(CtxR10,r4), r10
        .endf

;-------------------------------------------------------------------------------
; _DoSetRAMMode
; (r4) = BOOL bEnable
; (r5) = LPVOID *lplpvAddress
; (r6) = LPDWORD lpLength
; returns (r0) = old mode
;-------------------------------------------------------------------------------

        LEAF_ENTRY _DoSetRAMMode
        tst     r4,r4
        bt      disable
        mov     #h'1, r4                ; force to 0 or 1
disable:
        mov     #h'20000000,r0          ; (r0) = displacement between cached & un-cached space
        braf    r0
        stc     SR, r0
        .nopool
        or      #h'f0, r0
        ldc     r0, SR

        mov     #_bEnableRAMMode, r0
        mov     @r0, r3
        mov     r4, @r0

        cmp/eq  r3, r4
        bt      noswitch
        mov     #h'F4001000, r1         ; (r1) = ptr to memory mapped cache
        mov     #h'128/4, r2
        mov     #h'0, r0
loop1:
        mov     r0, @r1
        mov     r0, @(32,r1)
        add     #64, r1
        mov     r0, @r1
        mov     r0, @(32,r1)
        dt      r2
        bf/s    loop1
        add     #64, r1
        mov     #h'F4003000, r1         ; (r1) = ptr to 2nd half of memory mapped cache
        mov     #h'128/4, r2
loop2:
        mov     r0, @r1
        mov     r0, @(32,r1)
        add     #64, r1
        mov     r0, @r1
        mov     r0, @(32,r1)
        dt      r2
        bf/s    loop2
        add     #64, r1

        mov     #SH3CTL_BASE, r1
        mov.l   @(CCR,r1), r0
        xor     #h'20, r0
        mov.l   r0, @(CCR,r1)

noswitch:
        mov     #h'ffffff0f, r1
        stc     SR, r0
        and     r1, r0
        ldc     r0, SR
        tst.l   r5,r5
        bt      noaddr
        mov     #h'7c000000, r4
        mov     r4, @r5
noaddr:
        tst.l   r6, r6
        bt      nolength
        mov     #h'2000, r4
        mov     r4, @r6
nolength:
        rts
        mov     r3, r0
        .endf

PosTable:
        .data.b 0,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 7,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 8,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 7,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1
        .data.b 6,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _GetHighPos
        mov     #PosTable, r0
        mov     #-1, r6
        extu.b  r4, r5
        mov.b   @(r0,r5),r1
        tst.l   r1,r1
        bf      res
        add     #8, r6
        shlr8   r4

        extu.b  r4, r5
        mov.b   @(r0,r5),r1
        tst.l   r1,r1
        bf      res
        add     #8, r6
        shlr8   r4

        extu.b  r4, r5
        mov.b   @(r0,r5),r1
        tst.l   r1,r1
        bf      res
        add #8, r6
        shlr8   r4

        extu.b  r4, r5
        mov.b   @(r0,r5),r1
        tst.l   r1,r1
        bf      res
        mov     #9, r1

res:
        add     r6,r1
        rts
        mov     r1, r0

        .endf

;-------------------------------------------------------------------------------
;
; We move the PSL call and Callbacks to the end of the file becaue it doesn't fit
; in the exception vector space.
;
; The following code is never executed. Its purpose is to support unwinding
; through the call to the exception dispatcher.
;-------------------------------------------------------------------------------

        NESTED_ENTRY xSyscallHandler
        add     #-(CstkSizeof), r15    	; save space for a callstack structure
        sts.l   pr, r3                  ; (r3) = PR
        mov.l   r3, @(CstkRa, r15)      ; pcstk->dwRa = PR (save return address)        
        PROLOG_END

        ALTERNATE_ENTRY SyscallHandler

;-------------------------------------------------------------------------------
; Interrupts blocked, privleged mode, in BANK 1.
;
;   (r0_bank1): iMethod
;   (r2_bank1): SSR
;   (r4_bank1): pCurThread
;
;   (r0_bank0): return value if SYSCALL_RETURN (don't care if API call)
;   (r4-r7_bank0): function argument if API CALL
;-------------------------------------------------------------------------------

        ;
        ; check if this is a 1st call into PSL or if it is a return
        ;
        cmp/eq  #-1, r0
        bf      NotTrapRtn               ; PSL call if iMethod != -1

        ; 
        ; for returns, make sure pCurThread->pcstkTop != NULL
        ;
        mov.l   @(ThPcstkTop, r4), r1    ; (r1) = pCurThread->pcstkTop
        tst     r1, r1                   ; if (pCurThread->pcstkTop == 0), PSL call
        bt      NotTrapRtn               ; This is not a trap return
        
        bra     TrapRtn                  ; have to do it this way because 
        nop                              ; TrapRtn is out of range of bf or bt

NotTrapRtn:
        ;
        ; PSL call
        ;

        ; priveleged, bank 1, interrupts disabled
        
        ; (r0)_bank1 = iMethod
        ; (r2)_bank1 = SSR
        ; (r4)_bank1 = current thread
        ; (r4-r7)_bank0 = first four function arguments 
        
	; Obtain the execution mode from the top 8 bits of SR register.  The top 8 bits contain
        ; SR.MD(30, previledge mode), SR.RB(29, register bank), and SR.BL(28, interrupt block.)  
        ; Thus we can use the top 8 bits to determine the previous execution mode.  After 
        ; masking out other non-MD bits, the top 8 bits will have be 0x40 if MD bit is set
        ; and 0x0 otherwise.
        shlr16  r2
        shlr8   r2                      ; (r2) = old status >> 24

        ; mark for MD(Processor operation mode) bit
        mov     #h'40, r1               ; h'40 == KERNEL_MODE
        and     r1, r2                  ; (r2) = thread mode
        cmp/eq  r2, r1
        bf      UPSLCall                ; if user mode      

KPSLCall:
        ;
        ; PSL Call form KMODE, check if it's callback
        ;

        ; priveleged, bank 1, interrupts disabled
        
        ; (r0)_bank1 = iMethod
        ; (r2)_bank1 = KERNEL_MODE
        ; (r4)_bank1 = current thread
        ; (r4-r7)_bank0 = first four function arguments 

        ; update mode to be 0
        mov     #0, r2                  ; (r2) = 0 == CST_MODE_FROM_USER

        cmp/eq  #PERFORMCALLBACK, r0
        bf/s    PSLCommon               ; not a callback, switch to common PSL
        mov     r15, r1                 ; (delay slot) (r1) = SP

        ;
        ; PerformCallBack from kernel mode. Just enable interrupts, switch to bank 0, and jump to NKPerformCallBack
        ;
        mov     #PR_B0_IE, r1
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked

        bra    _NKPerformCallBack       ; handle callback if it is
        nop
        .nopool

UPSLCall:        
        ;
        ; PSL Call from user mode 
        ;

        ; priveleged, bank 1, interrupts disabled
        
        ; (r0)_bank1 = iMethod
        ; (r2)_bank1 = USER_MODE (== 0)
        ; (r4)_bank1 = current thread
        ; (r4-r7)_bank0 = first four function arguments 
        
        ; update TLS first
        mov.l   @(ThTlsSecure, r4), r3  ; (r3) = pCurThread->tlsSecure
        mov     #_KData+lpvTls, r1      ; (r1) = offset into TLS      
        mov.l   r3, @(ThTlsPtr, r4)     ; pCurThread->tlsPtr = pCurThread->tlsSecure
        mov.l   r3, @r1                 ; lpvTls = pCurThread->tlsSecure

        ; update mode to CST_MODE_FROM_USER
        mov     #CST_MODE_FROM_USER, r2 ; (r2) = CST_MODE_FROM_USER

        mov.l   @(ThPcstkTop, r4), r1   ; (r1) = pCurThread->pcstkTop
        tst     r1, r1                  ; Is pCurThread->pcstkTop NULL?
        bf      PSLCommon               ; SP is known

        ;
        ; no callstack (first trip into PSL), use tlsSecure to figure out new stack ptr
        ;       (r2) = pCurThread->tlsSecure
        ;        
        mov     #-SECURESTK_RESERVE, r1
        add     r3, r1                  ; (r1) = pCurThread->tlsSecure - SECURESTK_RESERVE

PSLCommon:

        ; priveleged, bank 1, interrupts disabled

        ; (r0)_bank1 = iMethod
        ; (r1)_bank1 = current sp on secure stack
        ; (r2)_bank1 = mode
        ; (r4)_bank1 = current thread
        ; (r4-r7)_bank0 = first four function arguments 

        mov     r15, r3                 ; (r3) = old sp
        mov     r1, r15                 ; (r15) = new sp
        add     #-CstkSizeof, r15       ; make room for callstack structure on stack

        ; pass information with bank0 registers
        ldc     r0, r3_user             ; pass method index
        ldc     r2, r2_user             ; pass previous mode
        ldc     r3, r1_user             ; pass old stack pointer

        mov     #PR_B0_IE, r1
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked

        ; priveleged, bank 0, interrupts enabled from here on

        ; (r1) = old stack pointer
        ; (r2) = previous mode
        ; (r3) = iMethod
        ; (r4-r7) = first four function arguments 
        ; (sp) = (r15) = pcstk

        ; setup callstack structure
        mov     r15, r0                         ; (r0) = pcstk
        add     #CstkNext, r0                   ; (r0) = &pcstk->pcstkNext
        mov.l   r3, @(CstkMethod-CstkNext, r0)  ; pcstk->iMethod = iMethod
        mov.l   r1, @(CstkPrevSP-CstkNext, r0)  ; pcstk->dwPrevSP = old sp
        mov.l   r2, @(CstkPrcInfo-CstkNext, r0) ; pcstk->dwPrcInfo = mode
        sts.l   pr, r3                          ; (r3) = PR
        mov.l   r3, @(CstkRa-CstkNext, r0)      ; pcstk->retAddr = PR

        ; save api arguments
        mov.l   r4, @r15
        mov.l   r5, @(REGSIZE, r15)
        mov.l   r6, @(2*REGSIZE, r15)
        mov.l   r7, @(3*REGSIZE, r15)

        ; save all callee saved registers
        add     #Cstk_REG_R8-CstkNext, r0       ; (r0) = &pcstk->regs[0]
        mov.l   r8,  @( 0, r0)
        mov.l   r9,  @( 4, r0)
        mov.l   r10, @( 8, r0)
        mov.l   r11, @(12, r0)
        mov.l   r12, @(16, r0)
        mov.l   r13, @(20, r0)
        mov.l   r14, @(24, r0)

        ; setup ObjectCall arguments
        mov     r15, r4                 ; (r4) = SP --> objectcall argument
        mov     #_ObjectCall, r0        ; r0 = ObjectCall

        jsr     @r0
        add     #-(4*REGSIZE), r15      ; (delay slot) C-calling convention, room for 4 registers

        add     #4*REGSIZE, r15         ; reclaim stack space

        ; (r0) = function to call
        mov     #CstkNewSP, r1          ; (r1) = offset to new SP
        add     r15, r1                 ; (r1) = &pcstk->dwNewsp
        mov.l   @r1, r1                 ; (r1) = pcstk->dwNewsp
        tst     r1,r1                   ; if (r1) == 0, kernel mode 
        bt      KernelModeFunc          ; call kernel function if true; 
                                        ; need to separate this as bt cannot reach
        ; (r0) = function to call
        ; (r1) = pcstk->dwNewsp
        bra     CallUModeFunc           ; call umode function if not        
        nop
        
KernelModeFunc:        
        ;
        ; kernel mode server --> call direct
        ; reload arguments
        ;
        mov.l   @r15, r4
        mov.l   @(REGSIZE, r15), r5
        mov.l   @(2*REGSIZE, r15), r6
        jsr     @r0
        mov.l   @(3*REGSIZE, r15), r7   ; (delay slot)

  ALTERNATE_ENTRY _APICallReturn

        .align  4

        ;
        ; r0 - return value
        ; r15 - pcstk
        ;

        ; save the return value in a non-volatile register
        mov     r0, r8                  ; (r8) = return value
        
        mov     #_ServerCallReturn, r1  ; (r1) == ServerCallReturn
        jsr     @r1                     ; call ServerCallReturn
        add     #-(4*REGSIZE), r15      ; (delay slot) C-calling convention, room for 4 registers

        add     #4*REGSIZE, r15         ; reclaim stack space

        ; restore return value
        mov     r8, r0                  ; (r0) = api return value
        
        ; restore all callee saved registers
        mov.l   #Cstk_REG_R8, r1
        add     r15, r1                 ; (r1) = &pcstk->regs[0]

        mov.l   @( 0, r1), r8
        mov.l   @( 4, r1), r9
        mov.l   @( 8, r1), r10
        mov.l   @(12, r1), r11
        mov.l   @(16, r1), r12
        mov.l   @(20, r1), r13
        mov.l   @(24, r1), r14

        ; restore mode, previous sp, and return address
        add     #CstkNext-Cstk_REG_R8, r1           ; (r1) = &pcstk->pcstkNext
        mov.l   @(CstkPrcInfo-CstkNext, r1), r2     ; (r2) = return mode
        mov.l   @(CstkRa-CstkNext, r1), r3          ; (r3) = pcstk->retAddr
        mov.l   @(CstkPrevSP-CstkNext, r1), r1      ; (r1) = previous sp   

        tst     r2, r2                  ; 
        bf      RtnToUMode              ; return to umode if (r2 != 0)

        ; else return to kmode, just jump to return address
        ; (r3) = address to continue at
        ; (r1) = target SP
        jmp     @r3
        mov     r1, r15                 ; (delay slot) reload sp
        
RtnToUMode:        
        ; Continue thread in user mode. This may be either an API call or
        ; an Callback.

        ; priveleged, bank 0, interrupts enabled        
        
        ; (r3) = address to continue at
        ; (r1) = target SP
    
        ; bank 0, exceptions enabled, interrupts masked
        mov     #PR_B0_IM, r2
        ldc     r2, SR                  ;

        ; priveleged, bank 0, exceptions enabled, interrupts masked        
        
        ldc     r3, SPC                 ; address to return
        mov     #0, r2                  ; (r2) = USER_MODE
        mov     r1, r15                 ; update SP
        
        ; Turn on/off FPU/DSP accordingly.
        mov     #_KData+g_CurFPUOwner, r1
        mov.l   @r1, r1
        mov     #_KData+pCurThd, r3
        mov.l   @r3, r3
        cmp/eq  r3,r1
        bt      geh16
        mov     #SR_FPU_DISABLED, r1
        or      r1, r2

geh16:

        ldc     r2, SSR
        rte
        nop
        .nopool
                
TrapRtn:

        ; priveleged, bank 1, interrupts disabled

        ; (r4) == pCurThread

        ; update SP
        mov.l   @(ThPcstkTop, r4), r15  ; (r15) = sp = pCurThread->pcstkTop

        ; update TLS
        mov.l   @(ThTlsSecure, r4), r2  ; (r2) = pCurThread->tlsSecure
        mov.l   r2, @(ThTlsPtr, r4)     ; pCurThread->tlsPtr = pCurThread->tlsSecure
        mov     #_KData+lpvTls, r3      
        mov.l   r2, @r3                 ; lpvTls = pCurThread->tlsSecure

        ; priveleged, bank 0, interrupts enabled from here on        
        mov     #PR_B0_IE, r1
        ldc     r1, SR                  ; (SR) = privileged, bank 0, unblocked

        ; jump to common entry point
        bra     _APICallReturn
        nop
        
        .endf

;-------------------------------------------------------------------------------
; INTERRUPTS_ENABLE - enable/disable interrupts based on arguemnt and return current status
;-------------------------------------------------------------------------------
        LEAF_ENTRY _INTERRUPTS_ENABLE
        stc     SR, r0          ; (r0) = SR
        mov     r0, r1          ; (r1) = SR
        tst     r4, r4          ; enable or disable?
        bt/s    UpdateSR        ; 
        or      #h'f0, r0       ; (r0) = SR with INT disabled (delay slot)

        ; enabling interrupt
        mov     #h'ffffff0f, r2 ; (r2) = mask
        and     r2, r0          ; (r0) = SR with INT enabled
        
UpdateSR:
        ldc     r0, SR          ; update SR
        mov     #h'f0, r0
        tst     r0, r1          ; was interrupt enabled? 
        bf/s    ReturnToCaller
        mov     #0, r0          ; return value, init to FALSE (delay slot)

        ; interrupt was enabled
        mov     #1, r0
        
ReturnToCaller:
        rts
        nop
        .endf   

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _NKIsSysIntrValid
        
        add     #-SYSINTR_DEVICES, r4           ; (r4) = idInt - SYSINTR_DEVICES
        cmp/pz  r4                              ; (r4) >= 0?
        bf      NKIRetFalse                     ; return FALSE if not
        mov     #SYSINTR_MAX_DEVICES, r0        ; (r0) = SYSINTR_MAX_DEVICES
        cmp/hs  r0, r4                          ; (r4) >= SYSINTR_MAX_DEVICES?
        bt      NKIRetFalse                     ; return FALSE if true

        ; idInt in range, return IntrEvents[idInt-SYSINTR_DEVICES]
        shll2   r4                              ; (r4) = (idInt-SYSINTR_DEVICES) * 4 == offset into IntrEvents
        mov     #_KData+alpeIntrEvents, r0      ; (r0) = &KData.alpeIntrEvents
        	
        rts
        mov     @(r0, r4), r0                   ; (delay slot) (r0) = IntrEvents[idInt-SYSINTR_DEVICES]

NKIRetFalse:
        rts
        mov     #0, r0                          ; (delay slot)
        
        .endf

;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------

        LEAF_ENTRY _NKCallIntChain
        
        ; save state 
        sts     pr,  @-r15              ; Save current return address
        
        ;
        ; Call the C function, NKCallIntChainWrapped
        ;
        mov     #_NKCallIntChainWrapped, r2
        jsr     @r2
        add.l   #-16, r15               ; (delay slot) reserve stack for 4 arguments, C calling convention
        
        add.l   #16, r15                ; reclaim stack
        lds     @r15+, pr               ; Restore return address

        rts
        nop

        .endf

;------------------------------------------------------------------------------
; MDSwitchToUserCode - final step of process creation
;------------------------------------------------------------------------------
        LEAF_ENTRY _MDSwitchToUserCode
        mov    r4, r0                  ; (r0) = function to call
        bra    CallUModeFunc
        mov    r5, r1                  ; (delay slot) (r1) = new SP
        .endf


;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; DWORD MDCallKernelHAPI (FARPROC pfnAPI, DWORD cArgs, LPVOID phObj, REGTYPE *pArgs)
;   - calling a k-mode handle-based API
;
; Uses R0, R10, R11, R12
; Passed in:
; R4 = pfnAPI
; R5 = cArgs
; R6 = phObj
; R7 = pArgs
;-------------------------------------------------------------------------------

        NESTED_ENTRY _MDCallKernelHAPI
        sts.l   pr, @-r15		; save return address
        add     #-(MAX_PSL_ARGS+2*REGSIZE), r15    	; room for arguments
        PROLOG_END

; copy argument (cArgs-4) from source (&arg[4]) to top of stack
	mov	r7, r1			; (r1) = pArgs
	add	#(3*REGSIZE), r1	; (r1) = &arg[4] = source
	mov	r15, r2	
	add	#(4*REGSIZE), r2	; (r2) = &sp[4] = dest
	add	#-4, r5			; (r5) = cArgs - 4

nextcopy:

; copy 1 argument in every iteration
	cmp/pz	r5
	bf/s	docall			; branch if no arguments left
	mov.l	@r1, r3			; (delay slot) (r3) = argv[i], i>=4
	mov.l	r3, @r2			; sp[j] = argv[i] save the arg on stack

	add	#REGSIZE, r1
	add	#REGSIZE, r2		; advance both dest and source
	bra	nextcopy
	add	#-1, r5			; (delay slot) decrement # to copy by 1
	
docall:
	mov	r4, r1			; (r1) = pfnAPI
	mov	r7, r2			; (r2) = pArgs
	
; setup r4-r7 and call the function
	mov	r6, r4			; (r4) = phObj
	mov.l	@r2, r5			; (r5) = args[1]
	mov.l	@(REGSIZE, r2), r0	; 
	mov	r0, r6			; (r6) = args[2]
	mov.l	@(2*REGSIZE, r2), r0	; 
	jsr	@r1			; function call
	mov	r0, r7			; (r7) = args[3] (delay slot)

; pop off stack and return        
        add.l   #(MAX_PSL_ARGS+2*REGSIZE), r15	; reclaim stack
        lds     @r15+, pr  		; Restore return address

        rts
        nop

        .endf


;-------------------------------------------------------------------------------
; DWORD MDCallUserHAPI (PHDATA phd, PDHCALL_STRUCT phc)
;   - calling a u-mode handle-based API
;-------------------------------------------------------------------------------
        NESTED_ENTRY _MDCallUserHAPI
        
        mov     r15, r1                 ; (r1) = SP
        add     #-(CstkSizeof), r15    	; index into the return address
        sts.l   pr, r3                  ; (r3) = PR
        mov.l   r3, @(CstkRa, r15)      ; pcstk->dwRa = PR (save return address)        
        PROLOG_END

        ; (r15) = pcstk
        mov.l   #CstkPrevSP, r0
        mov.l   r1, @(r0, r15)          ; pcstk->PrevSP = SP (save original SP)

        ; save all callee saved registers
        mov.l   #Cstk_REG_R8, r0
        mov.l   r8, @(r0, r15)
        mov.l   #Cstk_REG_R9, r0        
        mov.l   r9, @(r0, r15)
        mov.l   #Cstk_REG_R10, r0
        mov.l   r10, @(r0, r15)
        mov.l   #Cstk_REG_R11, r0
        mov.l   r11, @(r0, r15)
        mov.l   #Cstk_REG_R12, r0
        mov.l   r12, @(r0, r15)
        mov.l   #Cstk_REG_R13, r0
        mov.l   r13, @(r0, r15)
        mov.l   #Cstk_REG_R14, r0
        mov.l   r14, @(r0, r15)
        
        mov     r15, r6                  ; (r6) = pcstk --> third argument to SetupCallToUserServer
        mov     #_SetupCallToUserServer, r1
        jsr     @r1
        add     #-(4*REGSIZE), R15       ; (delay slot) C-calling convention, room for 4 registers

        add     #4*REGSIZE, r15          ; reclaim stack space
        
        ; (r0) = function to call
        mov     #CstkNewSP, r1           ; (r1) = offset to new SP
        add     r15, r1                  ; (r1) = &pcstk->dwNewSP
        mov.l   @r1, r1                  ; (r1) = pcstk->dwNewSP
        tst     r1,r1                    ; if (r1) == 0, kernel mode 

        ; (r0) = function to call
        ; (r1) = pcstk->dwNewSP
        bf/s    CallUModeFunc            ; call umode function if not

        ; resotre r4-r7
        mov.l   @r15, r4                 ; (delay slot)
        mov.l   @(REGSIZE, r15), r5
        mov.l   @(2*REGSIZE, r15), r6
        jsr     @r0
        mov.l   @(3*REGSIZE, r15), r7    ; (delay slot)

        ; jump to API return point
        bra     _APICallReturn
        nop
        
        .endf

;------------------------------------------------------------------------------
; NKPerformCallBack - calling back to user process
;------------------------------------------------------------------------------
        NESTED_ENTRY _NKPerformCallBack

        ; save arguments r4-r7 on stack (per C calling convention, 
        ; SP already reserved space for 4 args)
        mov.l   r4, @r15
        mov.l   r5, @(REGSIZE, r15)
        mov.l   r6, @(2*REGSIZE, r15)
        mov.l   r7, @(3*REGSIZE, r15)

        mov     r15, r1                 ; (r1) = original sp
        add     #-(CstkSizeof), r15     ; reserve callstack structure on stack
        sts.l   pr, r3                  ; (r3) = PR
        mov.l   r3, @(CstkRa, r15)      ; pcstk->dwRa = PR (save return address)        
        mov     #CstkPrevSP, r0
        mov.l   r1, @(r0, r15)          ; pcstk->PrevSP = SP (save original SP)

        ; save all callee saved registers
        mov.l   #Cstk_REG_R8, r0
        mov.l   r8, @(r0, r15)
        mov.l   #Cstk_REG_R9, r0        
        mov.l   r9, @(r0, r15)
        mov.l   #Cstk_REG_R10, r0
        mov.l   r10, @(r0, r15)
        mov.l   #Cstk_REG_R11, r0
        mov.l   r11, @(r0, r15)
        mov.l   #Cstk_REG_R12, r0
        mov.l   r12, @(r0, r15)
        mov.l   #Cstk_REG_R13, r0
        mov.l   r13, @(r0, r15)
        mov.l   #Cstk_REG_R14, r0
        mov.l   r14, @(r0, r15)
        
        PROLOG_END

        mov     r15, r4                 ; (r4) = argument = pcstk

        ;
        ; call NKPrepareCallback to setup callstack, figure out callee information
        ;
        mov     #_NKPrepareCallback, r2
        jsr     @r2
        add     #-(4*REGSIZE), r15      ; (delay slot) C-calling convention, room for 4 registers

        add     #(4*REGSIZE), r15       ; reclaim stack space

        ; (r0) = function to call
        mov     #CstkNewSP, r1          ; (r1) = offset to new SP
        add     r15, r1                 ; (r1) = &pcstk->dwNewSP
        mov.l   @r1, r1                 ; (r1) = pcstk->dwNewSP

        ;
        ; restore return address
        ;
        mov     #CstkRa, r2             ; (r2) = offset to return address
        add     r15, r2                 ; (r2) = &pcstk->dwRa
        mov.l   @r2, r2                 ; (r2) = pcstk->dwRa
        lds     r2, pr                  ; Return Address = PR = pcstk->dwRa

        tst     r1,r1                   ; if (r1) == 0, kernel mode 

        ; (r0) = function to call
        ; (r1) = pcstk->dwNewSP
        bf      CallUModeFunc           ; call umode function if not

        ; pop off the callstack strucure 
        ; need to split into two as size is 0x80       
        add     #CstkExtra, r15
        add     #(CstkSizeof-CstkExtra), r15

        ; restore r4-r7, and jump to function
        mov.l   @r15, r4
        mov.l   @(REGSIZE, r15), r5
        mov.l   @(2*REGSIZE, r15), r6
        jmp     @r0                     ; function to call
        mov.l   @(3*REGSIZE, r15), r7   ; (delay slot)

CallUModeFunc:

        ; (r0) = function to call
        ; (r1) = target sp, with arugments on stack
        stc     r4_bank, r2                 ; (r2) = pCurThread

        ; reload argument r4-r7
        mov.l   @r1, r4
        mov.l   @(REGSIZE, r1), r5
        mov.l   @(2*REGSIZE, r1), r6
        mov.l   @(3*REGSIZE, r1), r7
        mov.l   @(ThTlsNonSecure, r2), r3   ; (r3) = pCurThread->tlsNonSecure

        ; switch TLS
        mov.l   r3, @(ThTlsPtr, r2)         ; pCurThread->ThTlsPtr = pCurThread->tlsNonSecure
        mov     #_KData+lpvTls, r2
        mov.l   r3, @r2                     ; lpvTls = pCurThread->tlsNonSecure

        ; return address is SYSCALL_RETRUN
        mov     #SYSCALL_RETURN, r2
        lds     r2, pr
        
        bra     RtnToUMode
        mov     r0, r3                      ; (r3) = function to call (delay slot)
        
        .endf

        .end
