//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft shared
// source or premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license agreement,
// you are not authorized to use this source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the SOURCE.RTF on your install media or the root of your tools installation.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#include "storeincludes.hpp"

#ifdef UNDER_CE
#include <msgqueue.h>
#include <pnp.h>
#include <windev.h>
#endif

CRITICAL_SECTION g_csStoreMgr;
StoreDisk_t *g_pStoreRoot = NULL;
PSTOREHANDLE g_pRootHandle = NULL;

HANDLE g_hFindStoreApi = NULL;
HANDLE g_hFindPartApi  = NULL;
HANDLE g_hStoreApi     = NULL;
HANDLE g_hSTRMGRApi    = NULL;
HANDLE g_hPNPQueue = NULL;
HANDLE g_hPNPThread = NULL;
HANDLE g_hPNPUpdateEvent = NULL;
DWORD  g_dwUpdateState = 0;

DWORD  g_dwWaitIODelay = 0;

HANDLE g_hAutoLoadEvent = NULL;

HANDLE STRMGR_CreateFileW(DWORD dwData, HANDLE hProc, PCWSTR pwsFileName, DWORD dwAccess, DWORD dwShareMode,
                          PSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreate, DWORD dwFlagsAndAttributes,
                          HANDLE hTemplateFile, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD SecurityDescriptorSize);
BOOL   STRMGR_RefreshStore(DWORD dwData, const WCHAR* pFileName, const WCHAR*  pReserved);
HANDLE STRMGR_FindFirstFileW(DWORD dwData, HANDLE hProc, PCWSTR pwsFileSpec, PWIN32_FIND_DATAW pfd, DWORD SizeOfFindData);
BOOL   STRMGR_CloseAllHandles(DWORD dwData, HANDLE hProc);
DWORD  STRMGR_StubFunction(){   return 0;}

typedef HANDLE (* PREQUESTDEVICENOT)(const GUID *devclass, HANDLE hMsgQ, BOOL fAll);
typedef BOOL (* PSTOPDEVICENOT)(HANDLE h);

#ifdef UNDER_CE

// NOTE: The store and partition enumeration API sets really just map to 
// the standard file enumeration API set (HT_FIND).
CONST PFNAPI apfnFindStoreAPIs[NUM_FIND_APIS] = {
        (PFNAPI)STG_FindCloseStore,                     // FindClose
        (PFNAPI)NULL,
        (PFNAPI)STG_FindNextStore,                      // FindNextFileW
};

CONST ULONGLONG asigFindStoreAPIs[NUM_FIND_APIS] = {
        FNSIG1(DW),                                     // FindClose
        FNSIG0(),                                       //
        FNSIG3(DW,IO_PTR,DW)                            // FindNextFileW
};

CONST PFNAPI apfnFindPartAPIs[NUM_FIND_APIS] = {
        (PFNAPI)STG_FindClosePartition,
        (PFNAPI)NULL,
        (PFNAPI)STG_FindNextPartition,
};

CONST ULONGLONG asigFindPartAPIs[NUM_FIND_APIS] = {
        FNSIG1(DW),                                     // FindClose
        FNSIG0(),                                       //
        FNSIG3(DW,IO_PTR,DW)                            // FindNextFileW
};

// NOTE: The store-handle API set really just maps to the standard handle-
// based file API set (HT_FILE). Since invalid handle values are caught by
// the kernel before ever passing to these functions, OpenPartition and
// FindFirstPartition map to GetFileSize and SetFilePointer, which the
// kernel knows to return -1 (aka INVALID_HANDLE_VALUE) given a bad handle.
// The other functions map to file APIs which return FALSE given a bad handle.
CONST PFNAPI apfnSTGExternalAPIs[] = {
        (PFNAPI)STG_CloseHandle,                        // CloseHandle
        (PFNAPI)NULL,                                   // <pre-close>
        (PFNAPI)STG_DismountStore,                      // ReadFile
        (PFNAPI)STG_FormatStore,                        // WriteFile
        (PFNAPI)STGEXT_OpenPartition,                   // GetFileSize
        (PFNAPI)STGEXT_FindFirstPartition,              // SetFilePointer
        (PFNAPI)STG_CreatePartition,                    // GetFileInformationByHandle
        (PFNAPI)STG_MountPartition,                     // FlushFileBuffers
        (PFNAPI)STG_DismountPartition,                  // GetFileTime
        (PFNAPI)STG_RenamePartition,                    // SetFileTime
        (PFNAPI)STG_SetPartitionAttributes,             // SetEndOfFile
        (PFNAPI)STG_DeviceIoControl,                    // DeviceIoControl
        (PFNAPI)STG_GetPartitionInfo,                   // ReadFileWithSeek
        (PFNAPI)STG_FormatPartition,                    // WriteFileWithSeek
        (PFNAPI)STG_DeletePartition,                    // LockFileEx
        (PFNAPI)STG_GetStoreInfo                        // UnlockFileEx
};

CONST PFNAPI apfnSTGInternalAPIs[] = {
        (PFNAPI)STG_CloseHandle,
        (PFNAPI)NULL,
        (PFNAPI)STG_DismountStore,
        (PFNAPI)STG_FormatStore,
        (PFNAPI)STGINT_OpenPartition, 
        (PFNAPI)STGINT_FindFirstPartition,
        (PFNAPI)STG_CreatePartition,
        (PFNAPI)STG_MountPartition,
        (PFNAPI)STG_DismountPartition,
        (PFNAPI)STG_RenamePartition,
        (PFNAPI)STG_SetPartitionAttributes,
        (PFNAPI)STG_DeviceIoControl,
        (PFNAPI)STG_GetPartitionInfo,
        (PFNAPI)STG_FormatPartition,
        (PFNAPI)STG_DeletePartition,
        (PFNAPI)STG_GetStoreInfo
};

CONST ULONGLONG asigSTGAPIs[] = {
        FNSIG1(DW),                     // CloseHandle
        FNSIG0(),                       // 
        FNSIG1(DW),                     // DismountStore
        FNSIG1(DW),                     // FormatStore
        FNSIG2(DW,I_WSTR),              // OpenPartition
        FNSIG2(DW,IO_PDW),              // FindFirstPartition 
        FNSIG6(DW,I_WSTR,DW,DW,DW,DW),  // CreatePartition
        FNSIG1(DW),                     // MountPartition,
        FNSIG1(DW),                     // DismountPartition
        FNSIG2(DW,I_WSTR),              // RenamePartition
        FNSIG2(DW,DW),                  // SetPartitionAttributes    
        FNSIG8(DW,DW,IO_PTR,DW,IO_PTR,DW,O_PDW,IO_PDW), // DeviceIoControl
        FNSIG2(DW,IO_PDW),              // GetPartitionInfo    
        FNSIG3(DW,DW,DW),               // FormatPartition
        FNSIG2(DW,I_WSTR),              // DeletePartition
        FNSIG2(DW,IO_PDW)               // GetStoreInfo
};

CONST PFNAPI apfnSTGMGRAPIs[NUM_AFS_APIS] = {
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)NULL,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_CreateFileW,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_RefreshStore,
        (PFNAPI)STRMGR_FindFirstFileW,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_CloseAllHandles,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction,
        (PFNAPI)STRMGR_StubFunction
};

CONST ULONGLONG asigSTGMGRAPIs[NUM_AFS_APIS] = {
        FNSIG0(),                                       // CloseVolume
        FNSIG0(),                                       //
        FNSIG0(),                                       // CreateDirectoryW
        FNSIG0(),                                       // RemoveDirectoryW
        FNSIG0(),                                       // GetFileAttributesW
        FNSIG0(),                                       // SetFileAttributesW
        FNSIG9(DW,DW,I_WSTR,DW,DW,IO_PDW,DW,DW,DW),     // CreateFileW
        FNSIG0(),                                       // DeleteFileW
        FNSIG3(DW,I_WSTR,I_WSTR),                       // MoveFileW
        FNSIG5(DW,DW,I_WSTR,IO_PTR,DW),                 // FindFirstFileW
        FNSIG0(),                                       // CeRegisterFileSystemNotification
        FNSIG0(),                                       // CeOidGetInfo
        FNSIG0(),                                       // PrestoChangoFileName
        FNSIG2(DW,DW),                                  // CloseAllFiles
        FNSIG0(),                                       // GetDiskFreeSpace
        FNSIG0(),                                       // Notify
        FNSIG0(),                                       // CeRegisterFileSystemFunction
        FNSIG0(),                                       // FindFirstChangeNotification
        FNSIG0(),                                       // FindNextChangeNotification
        FNSIG0(),                                       // FindCloseChangeNotification
        FNSIG0(),                                       // CeGetFileNotificaitonInfo
        FNSIG0(),                                       // FsIoControl
        FNSIG0(),                                       // SetFileSecurityW
        FNSIG0(),                                       // GetFileSecurityW 
};

#endif // UNDER_CE

LRESULT InitializeStoreAPI ()
{
    DEBUGMSG (ZONE_INIT || ZONE_VERBOSE, (L"FSDMGR!InitializeStoreAPI\r\n"));

    InitializeCriticalSection(&g_csStoreMgr);

#ifdef UNDER_CE
    // Create the store enumeration API set (this is an HT_FIND set).
    g_hFindStoreApi = CreateAPISet(const_cast<CHAR*> ("FSTG"), sizeof(apfnFindStoreAPIs)/sizeof(apfnFindStoreAPIs[0]),
        reinterpret_cast<const PFNVOID *> (apfnFindStoreAPIs), asigFindStoreAPIs);
    if (!g_hFindStoreApi) {
        return FsdGetLastError (ERROR_GEN_FAILURE);
    }
    // Create the partition enumeration API set (this is an HT_FIND set).
    g_hFindPartApi = CreateAPISet(const_cast<CHAR*> ("FPRT"), sizeof(apfnFindPartAPIs)/sizeof(apfnFindPartAPIs[0]),
        reinterpret_cast<const PFNVOID *> (apfnFindPartAPIs), asigFindPartAPIs);
    if (!g_hFindPartApi) {
        return FsdGetLastError (ERROR_GEN_FAILURE);
    }
    // Create the store/partition I/O APi set (this is an HT_FILE set).
    g_hStoreApi  = CreateAPISet(const_cast<CHAR*> ("STRG"), sizeof(apfnSTGExternalAPIs)/sizeof(apfnSTGExternalAPIs[0]),
        reinterpret_cast<const PFNVOID *> (apfnSTGExternalAPIs), asigSTGAPIs);
    if (!g_hStoreApi) {
        return FsdGetLastError (ERROR_GEN_FAILURE);
    }

    // Register the previously created API sets.
    VERIFY (RegisterAPISet(g_hFindStoreApi, HT_FIND | REGISTER_APISET_TYPE));
    VERIFY (RegisterAPISet(g_hFindPartApi, HT_FIND | REGISTER_APISET_TYPE));
    VERIFY (RegisterAPISet(g_hStoreApi, HT_FILE | REGISTER_APISET_TYPE));
    RegisterDirectMethods (g_hStoreApi, (const PFNVOID*)apfnSTGInternalAPIs);
        
    // Register the storage manager AFS mount name. This hidden mount point will 
    // be used when performing storage manager API calls.
    int iAFS = INVALID_MOUNT_INDEX;
    iAFS = RegisterAFSName(L"StoreMgr");
    if ((iAFS == INVALID_MOUNT_INDEX) || (ERROR_SUCCESS != GetLastError())) {
        DEBUGMSG(ZONE_ERRORS, (L"FSDMGR!InitializeStoreAPI: failed registering StoreMgr volume name\r\n"));
        return FsdGetLastError (ERROR_GEN_FAILURE);
    }

    LRESULT lResult;

    // Create the storage manager AFS API set and associate it with the newly
    // registered mount point.
    g_hSTRMGRApi = CreateAPISet(const_cast<CHAR*> ("PFSD"), sizeof(apfnSTGMGRAPIs)/sizeof(apfnSTGMGRAPIs[0]),
        reinterpret_cast<const PFNVOID *> (apfnSTGMGRAPIs), asigSTGMGRAPIs);
    VERIFY (RegisterAPISet (g_hSTRMGRApi, HT_AFSVOLUME | REGISTER_APISET_TYPE));
    if (!g_hSTRMGRApi) {
        lResult = FsdGetLastError (ERROR_GEN_FAILURE);
        DeregisterAFSName(iAFS);
        return lResult;
    }
    if (!RegisterAFSEx(iAFS, g_hSTRMGRApi, (DWORD)1, AFS_VERSION, AFS_FLAG_HIDDEN)) {
        DEBUGMSG (ZONE_ERRORS, (L"FSDMGR!InitializeStoreAPI: failed registering StoreMgr volume\r\n"));
        lResult = FsdGetLastError (ERROR_GEN_FAILURE);
        DeregisterAFSName(iAFS);
        return lResult;
    }    
#endif // UNDER_CE

    return ERROR_SUCCESS;
}

BOOL STRMGR_CloseAllHandles(DWORD dwData, HANDLE hProc)
{
    return TRUE;
}


BOOL IsValidStore(StoreDisk_t *pStore)
{
    if (!pStore || (pStore == INVALID_STORE))
        return FALSE;
    LockStoreMgr();
    StoreDisk_t *pTemp = g_pStoreRoot;
    while( pTemp) {
        if (pTemp == pStore) {
            break;
        }    
        pTemp = pTemp->m_pNextStore;
    }
    UnlockStoreMgr();
    return pTemp != NULL;
}

void AddStore(StoreDisk_t *pStore)
{
// TODO: Add in the order of Disk Index ???
    if (g_pStoreRoot) {
        StoreDisk_t *pTemp = g_pStoreRoot;
        while(pTemp->m_pNextStore) {
            pTemp = pTemp->m_pNextStore;
        }
        pTemp->m_pNextStore = pStore;
    } else {
        g_pStoreRoot = pStore;
    }    
}

void DeleteStore(StoreDisk_t *pStore)
{
    StoreDisk_t *pTemp = g_pStoreRoot;
    if (g_pStoreRoot == pStore) {
        g_pStoreRoot = pStore->m_pNextStore;
    } else {    
        while(pTemp) {
            if (pTemp->m_pNextStore && (pTemp->m_pNextStore == pStore)) {
                break;
            }
            pTemp = pTemp->m_pNextStore;
        }    
        if (pTemp) {
            pTemp->m_pNextStore = pStore->m_pNextStore;
        }
    }
    delete pStore;
}

StoreDisk_t *FindStore(const WCHAR *szDeviceName)
{
    StoreDisk_t *pTemp = g_pStoreRoot;
    while(pTemp) {
        if (wcsicmp(szDeviceName, pTemp->m_szDeviceName) == 0) {
            break;
        }
        pTemp = pTemp->m_pNextStore;
    }    
    return pTemp;
}

BOOL MountStore (const WCHAR* pDeviceName, const GUID* pDeviceGuid, const WCHAR* pDriverPath, __out StoreDisk_t** ppStore)
{
    LRESULT lResult;
    
    LockStoreMgr ();

    StoreDisk_t* pStoreNew = FindStore (pDeviceName);
    if (pStoreNew && !(STORE_FLAG_DETACHED & pStoreNew->m_dwFlags)) {
        // There is an attached store with the same name as the new one
        // so we are unable to mount it (we can't have name conflicts).
        DEBUGMSG (ZONE_ERRORS, (L"FSDMGR: Store \"%s\" already exists ...skipping\r\n", pDeviceName));
        lResult = ERROR_ALREADY_EXISTS;
        goto exit;
    }

    // Look for a currently detached store.
    StoreDisk_t *pStoreExisting = g_pStoreRoot;
    while (pStoreExisting) {
        if (STORE_FLAG_DETACHED & pStoreExisting->m_dwFlags) {
            // Found a detached store.
            break;
        }
        pStoreExisting = pStoreExisting->m_pNextStore;
    }   

    // Allocate a new store.
    pStoreNew = new StoreDisk_t(pDeviceName, pDeviceGuid);
    if (!pStoreNew) {
        lResult = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    // Add the new store to our list of stores. It isn't ready for I/O yet because it
    // isn't completely mounted, but we need to open a handle to it to pass to the
    // partition driver so it must be on the list.
    AddStore (pStoreNew);

    if (pDriverPath) {
        
        // Auto-load stores will have a block device name specified.
        // Associate the specified block device with the store object.
        if (!pStoreNew->SetBlockDevice (pDriverPath)) {
            lResult = FsdGetLastError (ERROR_GEN_FAILURE);
            delete pStoreNew;
            goto exit;
        }
    }

    // Open a store handle to the new store to pass to the partition driver. It will
    // be ready for I/O once we've opened the disk handle in StoreDisk_t::MountStore.
    HANDLE hProc = reinterpret_cast<HANDLE> (GetCurrentProcessId ());
    HANDLE hStore = STG_OpenStore (pDeviceName, hProc);
    if (INVALID_HANDLE_VALUE == hStore) {        
        DEBUGMSG (ZONE_ERRORS, (L"FSDMGR!MountStore: Failed opening new store \"%s\"; error=%u\r\n", 
            pDeviceName, GetLastError ()));
        lResult = FsdGetLastError (ERROR_GEN_FAILURE);
        DeleteStore(pStoreNew);
        pStoreNew = NULL;
        goto exit;
    }

    DEBUGMSG (!pStoreExisting && ZONE_INIT, (L"FSDMGR!MountStore: Attaching new storage device \"%s\"", 
        pDeviceName));

    // Mount the new store. It will only be fully mounted if pStoreTemp == NULL.
    BOOL fMount = (NULL != pStoreExisting) ? FALSE : TRUE;
    lResult = pStoreNew->MountStore(hStore, fMount);
    if (ERROR_SUCCESS != lResult) {
        DEBUGMSG (ZONE_ERRORS, (L"FSDMGR!MountStore: Failed mounting store \"%s\"; error=%u\r\n", 
            pDeviceName, lResult));
        lResult = FsdGetLastError (ERROR_GEN_FAILURE);
        DeleteStore(pStoreNew);
        pStoreNew = NULL;
        goto exit;
    }
    
    if (pStoreExisting) {

        // There is an existing store marked as STORE_FLAG_DETACHED. See if any
        // detached store matches the new store.
        
        for (pStoreExisting = g_pStoreRoot; 
             pStoreExisting != NULL; 
             pStoreExisting = pStoreExisting->m_pNextStore) {

            if (!(STORE_FLAG_DETACHED & pStoreExisting->m_dwFlags)) {
                continue;
            }

            DEBUGCHK (pStoreExisting != pStoreNew);

            // Find an existing store object that looks like the new store object.
            pStoreExisting->Lock();
            if (pStoreExisting->CompareStores (pStoreNew)) {
                // Found a match.
                pStoreExisting->Unlock();
                break;
            }
            pStoreExisting->Unlock();
        }

        if (pStoreExisting) {

            //
            // A detached storage device has been re-inserted, so we will 
            // update the existing StoreDisk_t object with handles, device name, 
            // and partition info from the new StoreDisk_t object and free the 
            // new StoreDisk_t object. We keep the new partition driver context,
            // but keep the existing StoreDisk_t object.
            //
            
            pStoreExisting->Lock();

            // Swap contents from the new store into the existing store.
            pStoreExisting->SwapWithStore (pStoreNew);

            // Swap any store handles referencing the new store to now reference
            // the existing store. This swaps the partition driver's reference
            // to the new store's handle so partition i/o can continue transparently
            // without informing the partition driver.
            for (PSTOREHANDLE pHandle = g_pRootHandle;
                 pHandle != NULL;
                 pHandle = pHandle->pNext)
            {
                if (pHandle->pStore == pStoreNew) {
                    pHandle->pStore = pStoreExisting;
                }
            }

            // Remove the detached flag from the existing store as it is being
            // re-attached.
            pStoreExisting->m_dwFlags &= ~STORE_FLAG_DETACHED;
            
            // Re-enable the existing store.
            pStoreExisting->EnableStore ();
            pStoreExisting->Unlock();
            
            // Clean-up/free the new store object. The existing store object
            // will remain in place with updated partition information from
            // the new store object.
            pStoreNew->UnmountStore(TRUE);
            DeleteStore(pStoreNew);
            pStoreNew = NULL;
            
        } else {

            // This store does not match an existing, detached storage device, so 
            // we'll mount all existing partitions if the store is AUTOMOUNT.

            // Detach existing detached stores for good measure 
            // BUGBUG: The PNPThread will eventually detach these, so why do we do it here?
            DetachStores(STORE_FLAG_DETACHED);

            DEBUGMSG (ZONE_INIT, (L"FSDMGR!MountStore: Attaching new storage device \"%s\"", pDeviceName));

            if (STORE_ATTRIBUTE_AUTOMOUNT & pStoreNew->m_dwFlags) {
                
                // Auto-mount the partitions on the new store.
                PartitionDisk_t *pPartition = pStoreNew->m_pPartitionList;
                while(pPartition) {
                    pStoreNew->MountPartition(pPartition);
                    pPartition = pPartition->m_pNextPartition;
                }
            }
        }    
    }

    lResult = ERROR_SUCCESS;

exit:
    UnlockStoreMgr ();
    if ((ERROR_SUCCESS == lResult) && pStoreNew) {
        if (ppStore) {
            *ppStore = pStoreNew;
        }
        FSDMGR_AdvertiseInterface (&STORE_MOUNT_GUID, pStoreNew->m_szDeviceName, TRUE);
    }

    SetLastError (lResult);
    return (ERROR_SUCCESS == lResult);
}

// Called by PNPThread when after STRMGR_RefreshStore is called.
void WINAPI RefreshStores ()
{
    LockStoreMgr();
    BOOL fRet;
    StoreDisk_t *pStore = g_pStoreRoot;
    WCHAR szName[MAX_PATH];
    while(pStore) {
        if (pStore->m_dwFlags & STORE_FLAG_REFRESHED) {

            if (!(STORE_FLAG_DETACHED & pStore->m_dwFlags)) {

                StoreDisk_t *pStoreOld = pStore;

                pStoreOld->Lock();
                StringCchCopyW(szName, MAX_PATH, pStoreOld->m_szDeviceName);

                DEBUGMSG (ZONE_EVENTS, (L"FSDMGR!RefreshStores: Refreshing store \"%s\"\r\n", szName));

                // Zero-out the store's name so we can re-add it before deleting it.
                StringCbCopyW(pStoreOld->m_szOldDeviceName, sizeof (pStoreOld->m_szOldDeviceName), pStoreOld->m_szDeviceName);
                StringCbCopyW(pStoreOld->m_szDeviceName, sizeof (pStoreOld->m_szDeviceName), L"");

                fRet = pStoreOld->UnmountStore();

                // Invalidate any partition handles opened on this store.
                UpdateHandleFromList(pStoreOld->m_pRootHandle, pStoreOld, NULL);

                pStoreOld->Unlock();

                // Get the pointer to the next store.
                pStore = pStoreOld->m_pNextStore;

                if (fRet) {

                    //UpdateHandleFromList(g_pRootHandle, pStoreTemp, NULL);
                    FSDMGR_AdvertiseInterface( &STORE_MOUNT_GUID, pStoreOld->m_szDeviceName, FALSE);

                    WCHAR BlockDevice[MAX_PATH];
                    const WCHAR* pBlockDevice = NULL;
                    if (pStoreOld->m_pBlockDevice) {
                        // This is a block driver autoloaded by storage manager.
                        VERIFY (SUCCEEDED (StringCchCopyW (BlockDevice, MAX_PATH, pStoreOld->m_pBlockDevice->GetDeviceName())));
                        pBlockDevice = BlockDevice;
                    }
                    // else: this is a block driver loaded by device manager.

                    // Re-mount the store.
                    StoreDisk_t* pStoreNew = NULL;
                    if (MountStore (szName, &BLOCK_DRIVER_GUID, pBlockDevice, &pStoreNew)) {

                        // Swap any store handles referencing the old store to now reference
                        // the new store. If MountStore failed for some reason, this will
                        // invalidate the handles instead by setting pStore to NULL.
                        for (PSTOREHANDLE pHandle = g_pRootHandle;
                             pHandle != NULL;
                             pHandle = pHandle->pNext)
                        {
                            if (pHandle->pStore == pStoreOld) {
                                pHandle->pStore = pStoreNew;
                            }
                        }
                    } else {

                        // MountStore failed so invalidate any handle that were opened to
                        // the old store because it is now gone.
                        UpdateHandleFromList(g_pRootHandle, pStoreOld, NULL);
                    }

                    // Delete the old store.
                    DeleteStore (pStoreOld);
                }

            } else {

                // Only refresh detached stores. Those that are detached will
                // not be refreshed even if they become re-attached.
                pStore->m_dwFlags &= ~STORE_FLAG_REFRESHED;
            }
        } else {
            pStore = pStore->m_pNextStore;
        }
    }

    UnlockStoreMgr();
}

void WINAPI DetachStores (DWORD DetachMask)
{
    LockStoreMgr();

    StoreDisk_t *pDetachedStore;
    StoreDisk_t *pStore = g_pStoreRoot;

    while (pStore)
    {
        if ((STORE_FLAG_DETACHED & pStore->m_dwFlags) && 
            (STORE_FLAG_DETACHED & DetachMask))
        {
            // The store has been detached and has not come back online.
            pDetachedStore = pStore;
            pStore = pStore->m_pNextStore;

            // Completely unmount and delete the store.
            pDetachedStore->Lock ();
            DEBUGMSG (ZONE_INIT, (L"FSDMGR!DetachStores: Completing delayed detach of store \"%s\"\r\n", pDetachedStore->m_szOldDeviceName));
            pDetachedStore->UnmountStore ();
            UpdateHandleFromList (pDetachedStore->m_pRootHandle, 
                    pDetachedStore, NULL);
            pDetachedStore->Unlock ();
            UpdateHandleFromList (g_pRootHandle, pDetachedStore, NULL);

            FSDMGR_AdvertiseInterface (&STORE_MOUNT_GUID,
                pDetachedStore->m_szOldDeviceName, FALSE);

            // Free the store.
            DeleteStore (pDetachedStore);
        }
        else if ((STORE_FLAG_MEDIA_DETACHED & pStore->m_dwFlags) &&
                !(STORE_FLAG_MEDIA_DETACH_COMPLETE & pStore->m_dwFlags) &&
                 (STORE_FLAG_MEDIA_DETACHED & DetachMask))
        {
            // The media has been detached from this store, dismount it.
            pDetachedStore = pStore;
            pStore = pStore->m_pNextStore;

            // Completely unmount the store.
            pDetachedStore->Lock ();
            DEBUGMSG (ZONE_INIT, (L"FSDMGR!DetachStores: Completing media detach from store \"%s\"\r\n", pDetachedStore->m_szDeviceName));
            pDetachedStore->UnmountStore (FALSE);

            // Don't try to detach again.
            pDetachedStore->m_dwFlags |= STORE_FLAG_MEDIA_DETACH_COMPLETE;

            // Refresh this store to update the partition information.
            pDetachedStore->m_dwFlags |= STORE_FLAG_REFRESHED;

            pDetachedStore->Unlock ();
        }
        else
        {
            // This store is not detached.
            pStore = pStore->m_pNextStore;
        }
    }

    RefreshStores ();

    UnlockStoreMgr();
}

// NOTE: The storage manager must be locked before calling this function.
void SuspendStores ()
{
    StoreDisk_t *pStore = g_pStoreRoot;
    while (pStore) {
        
        pStore->Lock();
        
        if (pStore->m_pBlockDevice) {

            // For auto-loaded block drivers, we must call the PowerOn and
            // PowerOff exports on suspend/resume because device manager is
            // not aware of auto-loaded drivers.
            
            pStore->m_pBlockDevice->PowerOff ();
        }

        if (STORE_FLAG_DISABLE_ON_SUSPEND & pStore->m_dwFlags) {

            // On suspend, we need to permanently disable any devices that will be
            // de-activated and re-activated by their bus driver on resume. By doing
            // this, we make sure no threads will enter the volume from the time that
            // we suspend until the time that the device has been re-activated.

            DEBUGMSG (ZONE_POWER, (L"FSDMGR!SuspendStores: Disabling store \"%s\"\r\n", pStore->m_szDeviceName));       

            pStore->DisableStore ();
        }

        pStore->Unlock ();
        pStore = pStore->m_pNextStore;
    }
}

// NOTE: The storage manager must be locked before calling this function.
void ResumeStores ()
{
    StoreDisk_t *pStore = g_pStoreRoot;
    while (pStore) {
        
        pStore->Lock();
        
        if (pStore->m_pBlockDevice) {

            // For auto-loaded block drivers, we must call the PowerOn and
            // PowerOff exports on suspend/resume because device manager is
            // not aware of auto-loaded drivers.
            
            pStore->m_pBlockDevice->PowerOn ();
        }

        pStore->Unlock ();
        pStore = pStore->m_pNextStore;
    }
}

BOOL WINAPI UnmountStore(const WCHAR* pDeviceName)
{
    LockStoreMgr();
    StoreDisk_t *pStore = FindStore( pDeviceName);
    UnlockStoreMgr();
    if (pStore) {
        pStore->Lock();
        pStore->m_dwFlags |= STORE_FLAG_DETACHED;
        StringCbCopyW( pStore->m_szOldDeviceName, sizeof (pStore->m_szOldDeviceName), pStore->m_szDeviceName);
        StringCbCopyW( pStore->m_szDeviceName, sizeof (pStore->m_szDeviceName), L"");
        // Disable the store so that it cannot be used.
        pStore->DisableStore ();
        pStore->Unlock();
        LockStoreMgr();
        g_dwUpdateState |= STOREMGR_EVENT_UPDATETIMEOUT;
        SetEvent (g_hPNPUpdateEvent);
        UnlockStoreMgr();
        return TRUE;
    } 
    return FALSE;
}

BOOL DetachMedia (const WCHAR* pDeviceName)
{
    LRESULT lResult;

    LockStoreMgr ();

    // Find the store object associated with this device.
    StoreDisk_t* pStore = FindStore (pDeviceName);
    if (!pStore || (STORE_FLAG_DETACHED & pStore->m_dwFlags)) {
        lResult = ERROR_DEV_NOT_EXIST;
        goto exit;
    }

    pStore->Lock ();

    // Detach the media from the storage device.
    pStore->MediaDetachFromStore ();

    pStore->Unlock ();

    // Reset storage manager timeout. After timeout, the store will be
    // completely dismounted.
    g_dwUpdateState |= STOREMGR_EVENT_UPDATETIMEOUT;
    SetEvent (g_hPNPUpdateEvent);

    lResult = ERROR_SUCCESS;

exit:
    UnlockStoreMgr ();
    return (ERROR_SUCCESS == lResult);
}

BOOL AttachMedia (const WCHAR* pDeviceName)
{
    LRESULT lResult;

    LockStoreMgr ();

    // Find the store object associated with this device.
    StoreDisk_t* pStore = FindStore (pDeviceName);
    if (!pStore || (STORE_FLAG_DETACHED & pStore->m_dwFlags)) {
        lResult = ERROR_DEV_NOT_EXIST;
        goto exit;
    }

    pStore->Lock ();

    // Attach media to the store.
    pStore->MediaAttachToStore ();

    pStore->Unlock ();

    // Trigger refresh in case this store was marked as such.
    RefreshStores ();

    lResult = ERROR_SUCCESS;

exit:
    UnlockStoreMgr ();
    return (ERROR_SUCCESS == lResult);
}


BOOL AddHandleToList(PSTOREHANDLE *ppRoot, PSTOREHANDLE pHandle)
{
    DEBUGMSG(ZONE_VERBOSE, (L"FSDMGR!AddHandleToList: root=%08X pHandle=%08X\r\n", *ppRoot, pHandle));
    pHandle->pNext = *ppRoot;
    *ppRoot = pHandle;
    return TRUE;
}

BOOL DeleteHandleFromList(PSTOREHANDLE *ppRoot, PSTOREHANDLE pHandle)
{
    PSTOREHANDLE pTemp = *ppRoot;
    if (*ppRoot && pHandle) {
        if (*ppRoot == pHandle) {
            DEBUGMSG(ZONE_VERBOSE, (L"FSDMGR!DeleteHandleFromList: deleting with root=%08X pHandle=%08X\r\n", *ppRoot, pHandle));
            *ppRoot = pHandle->pNext;
            return TRUE;
        } 
        while( pTemp) {
            if (pTemp->pNext == pHandle) {
                pTemp->pNext = pHandle->pNext;
                DEBUGMSG(ZONE_VERBOSE, (L"FSDMGR!DeleteHandleFromList: Root=%08X pHandle=%08X <---Deleted\r\n", *ppRoot, pHandle));
                return TRUE;
            }
            DEBUGMSG(ZONE_VERBOSE, (L"FSDMGR!DeleteHandleFromList: pHandle=%08X\r\n", pTemp));
            pTemp = pTemp->pNext;
        }
    } 
    DEBUGMSG (ZONE_VERBOSE, (L"FSDMGR!DeleteHandleFromList: handle not found Root=%08X pHandle=%08X\r\n", *ppRoot, pHandle));
    return FALSE;
}

BOOL UpdateHandleFromList( PSTOREHANDLE pHandle, StoreDisk_t *pStore, PartitionDisk_t *pPartition)
{
    while(pHandle) {
        DEBUGMSG(ZONE_VERBOSE, (L"FSDMGR!UpdateHandleFromList: pHandle=%08X\r\n", pHandle));
        if (pHandle->pPartition == pPartition && pPartition) {
            if (pHandle->dwFlags & STOREHANDLE_TYPE_SEARCH) {
                pHandle->pPartition = pPartition->m_pNextPartition;
                pHandle->dwFlags |= STOREHANDLE_TYPE_CURRENT;
            } else {
                pHandle->pPartition = INVALID_PARTITION;
            }
        }   
        if (pHandle->pStore == pStore && pStore) {
            if (pHandle->dwFlags & STOREHANDLE_TYPE_SEARCH) {
                pHandle->pStore = pStore->m_pNextStore;
                pHandle->dwFlags |= STOREHANDLE_TYPE_CURRENT;
            } else {
                pHandle->pStore =  INVALID_STORE;
            }   
        }   
        pHandle = pHandle->pNext;
    }
    return TRUE;
}

#ifdef UNDER_CE

#define DEFAULT_TIMEOUT_RESET 5000
#define DEFAULT_WAITIO_MULTIPLIER 1

DWORD PNPThread(LPVOID lParam)
{
    static BYTE pPNPBuf[sizeof(DEVDETAIL) + 200];
    MSGQUEUEOPTIONS msgopts;
    DWORD dwFlags, dwSize;
    HANDLE hMediaNotify;
    HANDLE hBlockDeviceNotify;
    DEVDETAIL * pd = (DEVDETAIL *)pPNPBuf;
    GUID guid = {0};
    HANDLE pHandles[3];
    TCHAR szGuid[128];
    HMODULE hCoreDll;    
    DWORD dwTimeOut = INFINITE, dwTimeOutReset = DEFAULT_TIMEOUT_RESET;
    PSTOPDEVICENOT pStopDeviceNotification = NULL;
    PREQUESTDEVICENOT pRequestDeviceNotification = NULL;

    msgopts.dwSize = sizeof(MSGQUEUEOPTIONS);
    msgopts.dwFlags = 0;
    msgopts.dwMaxMessages = 0; //?
    msgopts.cbMaxMessage = sizeof(pPNPBuf);
    msgopts.bReadAccess = TRUE;
    
    g_hPNPQueue = CreateMsgQueue(NULL, &msgopts);

    if (!g_hPNPQueue) {
        DEBUGMSG (ZONE_ERRORS, (TEXT("FSDMGR!PNPThread: Unable to create PNP Message Queue...aborting PNPThread\r\n")));
        return FALSE;
    } 

    pHandles[0] = g_hPNPQueue;
    pHandles[1] = g_hPNPUpdateEvent;
    pHandles[2] = g_hAutoLoadEvent;

    HKEY hKey;
    if (ERROR_SUCCESS == FsdRegOpenKey( g_szSTORAGE_PATH, &hKey)) {
        DWORD dwPriority;
        if (!FsdGetRegistryValue(hKey, g_szReloadTimeOut, &dwTimeOutReset)) {
            dwTimeOutReset = DEFAULT_TIMEOUT_RESET;
        }
        if (FsdGetRegistryValue( hKey, g_szPNPThreadPrio, &dwPriority)) {
            CeSetThreadPriority(GetCurrentThread(), dwPriority); 
        }
        FsdRegCloseKey( hKey);
    }
    DEBUGMSG (ZONE_INIT, (L"FSDMGR!PNPThread: Using PNPUnloadDelay of %ld\r\n", dwTimeOutReset));

    hCoreDll = (HMODULE)LoadLibrary(L"coredll.dll");
    if (hCoreDll) {
        pRequestDeviceNotification = (PREQUESTDEVICENOT)FsdGetProcAddress( hCoreDll, L"RequestDeviceNotifications");
        pStopDeviceNotification = (PSTOPDEVICENOT)FsdGetProcAddress( hCoreDll, L"StopDeviceNotifications");
    }
    FreeLibrary( hCoreDll); // This is okay since we should already have a reference to coredll

    if (pRequestDeviceNotification)
    {
        DEBUGMSG (ZONE_INIT, (L"FSDMGR!PNPThread: PNPThread starting!\r\n"));
        hBlockDeviceNotify = pRequestDeviceNotification(&BLOCK_DRIVER_GUID, g_hPNPQueue, TRUE);
        DEBUGCHK (hBlockDeviceNotify);
        hMediaNotify = pRequestDeviceNotification(&STORAGE_MEDIA_GUID, g_hPNPQueue, TRUE);
        DEBUGCHK (hMediaNotify);
    }
    
    while(TRUE)
    {
        DWORD dwWaitCode;
        dwWaitCode = WaitForMultipleObjects (3, pHandles, FALSE, dwTimeOut);
        if (dwWaitCode == WAIT_TIMEOUT)
        {
            DEBUGMSG (ZONE_EVENTS, (L"FSDMGR!PNPThread: Scavenging stores\r\n"));
            LockStoreMgr();
            dwTimeOut = INFINITE;
            g_dwUpdateState &= ~STOREMGR_EVENT_UPDATETIMEOUT;
            UnlockStoreMgr();
            DetachStores(STORE_FLAG_DETACHED | STORE_FLAG_MEDIA_DETACHED);
        }
        else
        {
            DWORD dwEvent = dwWaitCode - WAIT_OBJECT_0;
            switch(dwEvent) {
                case 0: {
                    if (ReadMsgQueue(g_hPNPQueue, pd, sizeof(pPNPBuf), &dwSize, INFINITE, &dwFlags)) {
                        FsdStringFromGuid(&pd->guidDevClass, szGuid, 128);
                        DEBUGMSG (ZONE_EVENTS, (L"FSDMGR!PNPThread: Got a plug and play event %s Class(%s) Attached=%s!!!\r\n", pd->szName, szGuid, pd->fAttached ? L"TRUE":L"FALSE"));

                        if (0 == memcmp (&pd->guidDevClass, &BLOCK_DRIVER_GUID, sizeof(GUID))) {
                            if (pd->fAttached) {
                                MountStore (pd->szName, &pd->guidDevClass);
                            } else {
                                UnmountStore (pd->szName);
                            }

                        } else if (0 == memcmp (&pd->guidDevClass, &STORAGE_MEDIA_GUID, sizeof(GUID))) {
                            if (pd->fAttached) {
                                AttachMedia (pd->szName);
                            } else {
                                DetachMedia (pd->szName);
                            }
                        }
                    }
                    break;
                }
                case 1: {
                    if (g_dwUpdateState & STOREMGR_EVENT_UPDATETIMEOUT) {
                        dwTimeOut = dwTimeOutReset;
                    }
                    if (g_dwUpdateState & STOREMGR_EVENT_REFRESHSTORE) {
                        RefreshStores ();
                    }
                    break;
                }
                case 2:
                    ResetEvent( g_hAutoLoadEvent);
                    AutoLoadFileSystems( 2, LOAD_FLAG_ASYNC);
                    break;
                default:
                    break;
            }   
        }    
    }    
    // SHould never get here !!!
    if (pStopDeviceNotification) {
        pStopDeviceNotification(hMediaNotify);
        pStopDeviceNotification(hBlockDeviceNotify);
    }
    return 0;
}

LRESULT InitializeStorageManager (DWORD BootPhase)
{
    // Create PNP thread events, and start the PNP thread.
    if (!g_hPNPThread) {
        g_hPNPUpdateEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (!g_hPNPUpdateEvent) {
            return FsdGetLastError (ERROR_GEN_FAILURE);
        }
        g_hAutoLoadEvent = CreateEvent (NULL, TRUE, FALSE, L"SYSTEM/AutoLoadFileSystems");
        if (!g_hAutoLoadEvent) {
            return FsdGetLastError (ERROR_GEN_FAILURE);
        }

        // Load storage manager registry values:
        //
        // [HKLM\System\StorageManager]
        //
        //      PNPUnloadDelay=dword:xxx
        // 
        //      PNPWaitIODelay=dword:xxx
        //
        HKEY hKey;
        if (ERROR_SUCCESS == FsdRegOpenKey( g_szSTORAGE_PATH, &hKey)) {
            DWORD dwTimeoutReset;
            if (!FsdGetRegistryValue(hKey, g_szReloadTimeOut, &dwTimeoutReset)) {
                dwTimeoutReset = DEFAULT_TIMEOUT_RESET;
            }
            if (!FsdGetRegistryValue( hKey, g_szWaitDelay, &g_dwWaitIODelay)) {
                g_dwWaitIODelay = dwTimeoutReset * DEFAULT_WAITIO_MULTIPLIER;
            }
            FsdRegCloseKey( hKey);
        }

        g_hPNPThread = CreateThread (NULL, 0, PNPThread, NULL, 0, NULL);
        if (!g_hPNPThread) {
            DEBUGMSG (ZONE_ERRORS, (L"FSDMGR!InitializeStoreAPI: PNPThread failed to start!\r\n"));
            return FsdGetLastError (ERROR_GEN_FAILURE);
        }
    }

    if (2 == BootPhase) {
        // If this is BootPhase 2, signall the PNP thread to process asynchronous
        // auto-load tasks.
        SetEvent(g_hAutoLoadEvent);
    }
    
    return ERROR_SUCCESS;
}

#endif

// External API's
// SECURITY NOTE: Filesys validated, canonicalized, and locally copied "pwsFileName."
// Filesys also validated that the caller has permission to perform the operation.
HANDLE STRMGR_CreateFileW(DWORD dwData, HANDLE hProc, PCWSTR pwsFileName, DWORD dwAccess, DWORD dwShareMode,
                          PSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreate, DWORD dwFlagsAndAttributes,
                          HANDLE hTemplateFile, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD SecurityDescriptorSize)
{
    if (*pwsFileName == L'\\') 
        pwsFileName++;
    return STG_OpenStore( pwsFileName, hProc);
}

// SECURITY NOTE: Filesys validated, canonicalized, and locally copied "pwsFileSpec."
// Filesys also validated that the caller has permission to perform the operation.
HANDLE STRMGR_FindFirstFileW(DWORD dwData, HANDLE hProc, PCWSTR pwsFileSpec, WIN32_FIND_DATA *pfd, DWORD SizeOfFindData)
{
#ifdef UNDER_CE
    if (sizeof (STOREINFO) != SizeOfFindData) {
        DEBUGCHK (0); // AFS_FindFirstFileW_Trap macro was called directly w/out proper size.
        SetLastError (ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }   
#endif

    STOREINFO *pInfo = (STOREINFO*)pfd;
    return STG_FindFirstStore(pInfo, hProc);
}

// NOTE: This API is called from MoveFile.
// SECURITY NOTE: Filesys validated, canonicalized, and locally copied "pwsFileName."
// Filesys also validated that the caller has permission to perform the operation.
BOOL   STRMGR_RefreshStore(DWORD dwData, const WCHAR* pFileName, const WCHAR*  pReserved)
{
    if (*pFileName == L'\\') 
        pFileName++;
    LockStoreMgr();
    StoreDisk_t *pStore = FindStore( pFileName);
    if (pStore) {
        pStore->Lock();
        pStore->m_dwFlags |= STORE_FLAG_REFRESHED;
        pStore->Unlock();
        g_dwUpdateState |= STOREMGR_EVENT_REFRESHSTORE;
        SetEvent( g_hPNPUpdateEvent);
    } else {
        MountStore (pFileName, &BLOCK_DRIVER_GUID);
    }
    UnlockStoreMgr();
    return TRUE;
}

EXTERN_C PDSK FSDMGR_DeviceHandleToHDSK(HANDLE hDevice)
{    
    LockStoreMgr();

    StoreDisk_t *pTempStore = g_pStoreRoot;
    if (NULL == g_pStoreRoot) {
        UnlockStoreMgr ();
        return NULL;
    }

    // Locate the store matching the specified handle
    while(pTempStore) {
        if ((hDevice == pTempStore->m_hStore) ||
            (hDevice == pTempStore->m_hDisk)) {
            break;
        }
        pTempStore = pTempStore->m_pNextStore;
    }

    UnlockStoreMgr();

    return pTempStore;
}

