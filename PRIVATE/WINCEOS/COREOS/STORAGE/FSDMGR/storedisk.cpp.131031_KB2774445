//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft shared
// source or premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license agreement,
// you are not authorized to use this source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the SOURCE.RTF on your install media or the root of your tools installation.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#include "storeincludes.hpp"

DWORD  g_dwBlockDevCount = 0;

StoreDisk_t::StoreDisk_t(const WCHAR *szDeviceName, const GUID* pDeviceGuid) :
        m_pNextStore(NULL),
        m_dwStoreId(NULL),
        m_dwFlags(0),
        m_pPartDriver(NULL),
        m_pPartitionList(NULL),
        m_dwPartCount(0),
        m_dwMountCount(0),
        m_pRootHandle(NULL),
        m_hActivityEvent(NULL),
        m_dwDefaultMountFlags(0),
        m_hDisk(NULL),
        m_hStore(NULL),
        m_pStorageId(NULL),
        m_pBlockDevice(NULL),
        m_dwRefCount(0),
        m_dwPowerCount(0)
{
    memset( &m_si, 0, sizeof(PD_STOREINFO));
    memset( &m_sdi, 0, sizeof(STORAGEDEVICEINFO));
    memcpy( &m_DeviceGuid, pDeviceGuid, sizeof(GUID));
    VERIFY(SUCCEEDED(StringCchCopy( m_szPartDriver, MAX_PATH, L"")));
    VERIFY(SUCCEEDED(StringCchCopy( m_szPartDriverName, 32, L"")));
    // This name might be longer than DEVICENAMESIZE because it
    // is taken directly from the registry for autoload block devices.
    // If it is longer than DEVICENAMESIZE, this will truncate the string.
    StringCchCopy( m_szDeviceName, DEVICENAMESIZE, szDeviceName);
    VERIFY(SUCCEEDED(StringCchCopy( m_szStoreName, STORENAMESIZE, g_szDEFAULT_STORAGE_NAME)));
    VERIFY(SUCCEEDED(StringCchCopy( m_szDefaultFileSystem, MAX_PATH, g_szDEFAULT_FILESYSTEM)));
    VERIFY(SUCCEEDED(StringCchCopy( m_szRootRegKey, MAX_PATH, L"")));
    VERIFY(SUCCEEDED(StringCchCopy( m_szOldDeviceName, DEVICENAMESIZE, L"")));
    VERIFY(SUCCEEDED(StringCchCopy( m_szFolderName, FOLDERNAMESIZE, g_szDEFAULT_FOLDER_NAME)));
    VERIFY(SUCCEEDED(StringCchCopy( m_szActivityName, MAX_PATH, L"")));
    InitializeCriticalSection( &m_cs);

// TODO: Read this from the registry
    m_dwFlags = 0;

    m_ThisLogicalDiskType = StoreDisk_Type;
}
        
StoreDisk_t::~StoreDisk_t()
{
   DEBUGMSG(ZONE_INIT, (L"FSDMGR!StoreDisk_t::~StoreDisk_t: deleting store (%p)", this));
// Delete the Partitions
// Delete the Partition Driver
    if (m_pPartDriver) {
        if (m_dwStoreId)
            m_pPartDriver->CloseStore( m_dwStoreId);
        delete m_pPartDriver;
    }
    if (m_pStorageId) {
        delete [] m_pStorageId;
    }
#ifdef UNDER_CE
    if (m_hDisk) {
        ::CloseHandle (m_hDisk);
    }
    if (m_hStore) {
        ::CloseHandle (m_hStore);
    }
#else
    if (m_hDisk) {
        ::FS_DevCloseFileHandle (reinterpret_cast<BlockDevice_t*> (m_hDisk));
    }
    
    if (m_hStore) {
        ::STG_CloseHandle (reinterpret_cast<PSTOREHANDLE> (m_hStore));
    }
#endif // UNDER_CE

    if (m_pBlockDevice) {
        delete m_pBlockDevice;
    }
    if (m_hActivityEvent) {
        ::CloseHandle( m_hActivityEvent);
    }
    ::DeleteCriticalSection(&m_cs);
}

void StoreDisk_t::PowerOff()
{
    Lock();
    if (++m_dwPowerCount ==m_dwMountCount) {
        if (m_pBlockDevice) {
            m_pBlockDevice->PowerOff();
        }
    }
    Unlock();
}

void StoreDisk_t::PowerOn()
{
    Lock();
    if (m_dwPowerCount == m_dwMountCount) {
        if (m_pBlockDevice) {
            m_pBlockDevice->PowerOn();
        }
    }
    m_dwPowerCount--;
    Unlock();
}

BOOL StoreDisk_t::SetBlockDevice(const TCHAR *szDriverName)
{
    m_pBlockDevice = new BlockDevice_t(szDriverName);
    return (NULL != m_pBlockDevice);
}

// Perform a swap of the information from pStoreNew into this store. This function
// is used by MountStore when we're re-mounting an existing, detached store.
void StoreDisk_t::SwapWithStore (StoreDisk_t* pStoreNew)
{    
    DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::SwapWithStore: Re-attaching storage device \"%s\" (was \"%s\")", 
        pStoreNew->m_szDeviceName, m_szOldDeviceName));

    // Close resources associated with the existing store.
    m_pPartDriver->CloseStore(m_dwStoreId);         

#ifdef UNDER_CE    
    ::CloseHandle(m_hDisk);    
    ::CloseHandle(m_hStore);
#else
    ::FS_DevCloseFileHandle (reinterpret_cast<BlockDevice_t*> (m_hDisk);
    ::STG_CloseHandle (reinterpret_cast<PSTOREHANDLE> (m_hStore));
#endif
    
    // Replace existing resources with the resources from the new store.
    m_dwStoreId = pStoreNew->m_dwStoreId;
    m_hDisk = pStoreNew->m_hDisk;
    m_hStore = pStoreNew->m_hStore;
    
    // NULL the copied values from the new store so that they won't be
    // freed. The old store now refers to them.
    pStoreNew->m_dwStoreId = 0;
    pStoreNew->m_hDisk = NULL;
    pStoreNew->m_hStore = NULL;
        
    // Device name could have changed (e.g. DSK1: is now DSK2: though the
    // physical device is the same), so copy the new name over the existing 
    // store name.
    VERIFY (SUCCEEDED (::StringCchCopyW (m_szDeviceName, DEVICENAMESIZE, pStoreNew->m_szDeviceName)));
    VERIFY (SUCCEEDED (::StringCchCopyW (m_szOldDeviceName, DEVICENAMESIZE, pStoreNew->m_szDeviceName)));
    
    // Copy partition information from the new store to the existing store.
    PartitionDisk_t *pPartitionExisting = m_pPartitionList;
    PartitionDisk_t *pPartitionNew = pStoreNew->m_pPartitionList;
    while(pPartitionExisting) {
        DEBUGCHK (pPartitionNew);
        pPartitionExisting->m_dwPartitionId = pPartitionNew->m_dwPartitionId;
        pPartitionExisting->m_dwStoreId = pPartitionNew->m_dwStoreId;
        pPartitionNew->m_dwPartitionId = 0;
        pPartitionNew->m_dwStoreId = 0;
        
        pPartitionExisting = pPartitionExisting->m_pNextPartition;
        pPartitionNew = pPartitionNew->m_pNextPartition;
    }
}

BOOL StoreDisk_t::GetStoreInfo(STOREINFO *pInfo)
{
    __try {
        pInfo->dwAttributes = m_si.dwAttributes;
        pInfo->snBiggestPartCreatable = m_si.snBiggestPartCreatable;
        pInfo->dwBytesPerSector = m_si.dwBytesPerSector;
        pInfo->snFreeSectors = m_si.snFreeSectors;
        pInfo->snNumSectors = m_si.snNumSectors;
        pInfo->dwPartitionCount = m_dwPartCount;
        pInfo->dwMountCount = m_dwMountCount;
        pInfo->dwDeviceClass = m_sdi.dwDeviceClass;
        pInfo->dwDeviceFlags = m_sdi.dwDeviceFlags;
        pInfo->dwDeviceType = m_sdi.dwDeviceType;
        VERIFY(SUCCEEDED(StringCchCopy( pInfo->szDeviceName, DEVICENAMESIZE, m_szDeviceName)));
        VERIFY(SUCCEEDED(StringCchCopy( pInfo->szStoreName, STORENAMESIZE, m_szStoreName)));
        memcpy( &pInfo->ftCreated, &m_si.ftCreated, sizeof(FILETIME));
        memcpy( &pInfo->ftLastModified, &m_si.ftLastModified, sizeof(FILETIME));
        memcpy( &pInfo->sdi, &m_sdi, sizeof(STORAGEDEVICEINFO));
    } __except( EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    return TRUE;
}

BOOL StoreDisk_t::GetPartitionDriver(HKEY hKeyStorage, HKEY hKeyProfile)
{
    BOOL fValidDriver = FALSE, fValidName = FALSE;

    if (hKeyProfile) {
        // try to read the partition driver name from the profile key
        fValidName = FsdGetRegistryString(hKeyProfile, g_szPART_DRIVER_NAME_STRING, m_szPartDriverName, sizeof(m_szPartDriverName)/sizeof(WCHAR));
    }

    if (!fValidName && hKeyProfile) {
        // allow the legacy partition driver DLL name specified in the profile
        fValidDriver = FsdGetRegistryString(hKeyProfile, g_szPART_DRIVER_STRING, m_szPartDriver, sizeof(m_szPartDriver)/sizeof(WCHAR));
    }

    if (!fValidName && !fValidDriver && hKeyStorage) {
        // try to read the partition driver name from the storage key
        fValidName = FsdGetRegistryString(hKeyStorage, g_szPART_DRIVER_NAME_STRING, m_szPartDriverName, sizeof(m_szPartDriverName)/sizeof(WCHAR));
    }

    if (fValidName && !fValidDriver) {
        // open the partition driver sub key
        HKEY hKeyPartition;
        TCHAR szSubKey[MAX_PATH];

        if (hKeyProfile) {
            // try to find the dll name under the profile partition driver sub key
            if (ERROR_SUCCESS == FsdRegOpenSubKey(hKeyProfile, m_szPartDriverName, &hKeyPartition)) {
                fValidDriver = FsdGetRegistryString(hKeyPartition, g_szPART_DRIVER_MODULE_STRING, m_szPartDriver, sizeof(m_szPartDriver)/sizeof(WCHAR));
                FsdRegCloseKey(hKeyPartition);
            }
        }

        if (!fValidDriver && hKeyStorage) {
            // try to find the dll name under the storage root partition driver key
            VERIFY(SUCCEEDED(StringCchPrintf(szSubKey, MAX_PATH, L"%s\\%s", g_szSTORAGE_PATH, m_szPartDriverName)));
            if (ERROR_SUCCESS == FsdRegOpenKey(szSubKey, &hKeyPartition)) {
                fValidDriver = FsdGetRegistryString(hKeyPartition, g_szPART_DRIVER_MODULE_STRING, m_szPartDriver, sizeof(m_szPartDriver)/sizeof(WCHAR));
                FsdRegCloseKey(hKeyPartition);
            }
        }

    }

    if (!fValidDriver) {
        // unable to find a valid driver in the registry
        DEBUGMSG (1, (L"FSDMGR!StoreDisk_t::GetPartitionDriver: Using the default HARDCODED partitioning driver (%s)!!!\r\n", g_szDEFAULT_PARTITION_DRIVER));
        VERIFY(SUCCEEDED(StringCchCopy( m_szPartDriver, MAX_PATH, g_szDEFAULT_PARTITION_DRIVER)));
    }

    if (!fValidName) {
        // unable to find a valid partition driver name in the registry,
        // generate the name from the name of the driver
        TCHAR *pszTmp;
        StringCbCopyW (m_szPartDriverName, sizeof(m_szPartDriverName), m_szPartDriver);
        if (pszTmp = wcsstr( m_szPartDriverName, L".")) {
            *pszTmp = L'\0';
        }
        DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::GetPartitionDriver: Using the generated partition driver name (%s)!!!\r\n", m_szPartDriverName));
    }

    return TRUE;
}

BOOL StoreDisk_t::GetStoreSettings()
{
    HKEY hKeyStorage=NULL, hKeyProfile = NULL;
    BOOL bRet = FALSE;
    if (ERROR_SUCCESS == FsdRegOpenKey( g_szPROFILE_PATH, &hKeyStorage)) {
        DUMPREGKEY(ZONE_INIT, g_szPROFILE_PATH, hKeyStorage);
        VERIFY(SUCCEEDED(StringCchPrintf(m_szRootRegKey, MAX_PATH, L"%s\\%s", g_szPROFILE_PATH, m_sdi.szProfile)));
        if (ERROR_SUCCESS != FsdRegOpenKey( m_szRootRegKey, &hKeyProfile)) {
            hKeyProfile = NULL;
        } else {
            DUMPREGKEY(ZONE_INIT, m_sdi.szProfile, hKeyProfile);
        }
        // Read settings from the storage profile and the base profile:
        // 
        // Storage Profile (hKeyProfile):
        //
        //     HKLM\System\StorageManager\Profiles\<ProfileName>
        //
        // Base Profile (hKeyStorage):
        //
        //     HKLM\System\StorageManager\Profiles
        //
        // Load the AutoMount setting.
        if (!hKeyProfile || !FsdLoadFlag(hKeyProfile, g_szAUTO_MOUNT_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOMOUNT)) {
            if (!FsdLoadFlag(hKeyStorage, g_szAUTO_MOUNT_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOMOUNT)) {
                // AutoMount=TRUE is the default if it was not specified in either profile.
                m_dwFlags |= STORE_ATTRIBUTE_AUTOMOUNT;
            }
        }
        // Load the AutoFormat setting.
        if (!hKeyProfile || !FsdLoadFlag(hKeyProfile, g_szAUTO_FORMAT_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOFORMAT)) {
            FsdLoadFlag(hKeyStorage, g_szAUTO_FORMAT_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOFORMAT);
        }
        // Load the AutoPart setting.
        if (!hKeyProfile || !FsdLoadFlag(hKeyProfile, g_szAUTO_PART_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOPART)) {
            FsdLoadFlag(hKeyStorage, g_szAUTO_PART_STRING, &m_dwFlags, STORE_ATTRIBUTE_AUTOPART);
        }
        // Load the DefaultFileSystem setting.
        if (!hKeyProfile || !FsdGetRegistryString(hKeyProfile, g_szFILE_SYSTEM_STRING, m_szDefaultFileSystem, sizeof(m_szDefaultFileSystem)/sizeof(WCHAR))) {
            if (!FsdGetRegistryString(hKeyStorage, g_szFILE_SYSTEM_STRING, m_szDefaultFileSystem, sizeof(m_szDefaultFileSystem)/sizeof(WCHAR))) {
                // "FATFS" is the default file system if none was specified in either profile.
                VERIFY(SUCCEEDED(StringCchCopy( m_szDefaultFileSystem, MAX_PATH, g_szDEFAULT_FILESYSTEM)));
            }
        }
        // Load the Folder setting.
        if (!hKeyProfile || !FsdGetRegistryString(hKeyProfile, g_szFOLDER_NAME_STRING, m_szFolderName, sizeof(m_szFolderName)/sizeof(WCHAR))) {
            if (!FsdGetRegistryString(hKeyStorage, g_szFOLDER_NAME_STRING, m_szFolderName, sizeof(m_szFolderName)/sizeof(WCHAR))) {
                // "Mounted Volume" is the default folder name if none was specified in either profile.
                VERIFY(SUCCEEDED(StringCchCopy( m_szFolderName, FOLDERNAMESIZE, g_szDEFAULT_FOLDER_NAME)));
            }
        }
        // Load the Name setting; this is really the friendly name for th estore.
        if (!hKeyProfile || !FsdGetRegistryString(hKeyProfile, g_szSTORE_NAME_STRING, m_szStoreName, sizeof(m_szStoreName)/sizeof(WCHAR))) {
            if (!FsdGetRegistryString(hKeyStorage, g_szSTORE_NAME_STRING, m_szStoreName, sizeof(m_szStoreName)/sizeof(WCHAR))) {
                // "External Storage" is the default name if none was specified in either profile.
                VERIFY(SUCCEEDED(StringCchCopy( m_szStoreName, STORENAMESIZE, g_szDEFAULT_STORAGE_NAME)));
            }
        }
        // By default activity timer is enabled.  The Event Strings will specify the name of the activity event.
        if (!hKeyProfile || !FsdLoadFlag(hKeyProfile, g_szACTIVITY_TIMER_ENABLE_STRING, &m_dwFlags, STORE_FLAG_ACTIVITYTIMER)) {
            if (!FsdLoadFlag(hKeyStorage, g_szACTIVITY_TIMER_ENABLE_STRING, &m_dwFlags, STORE_FLAG_ACTIVITYTIMER)) {
                m_dwFlags |= STORE_FLAG_ACTIVITYTIMER;
            } 
        }
        // Load the ActivityEvent setting.
        if (!hKeyProfile || !FsdGetRegistryString( hKeyProfile, g_szACTIVITY_TIMER_STRING, m_szActivityName, sizeof( m_szActivityName)/sizeof(WCHAR))) {
            if (!FsdGetRegistryString(hKeyStorage, g_szACTIVITY_TIMER_STRING, m_szActivityName, sizeof(m_szActivityName)/sizeof(WCHAR))) {
                // By default, there is no activity event name and hence no activity event.
                VERIFY(SUCCEEDED(StringCchCopy( m_szActivityName, MAX_PATH, g_szDEFAULT_ACTIVITY_NAME)));
            }
        }

        // Load the DisableOnSuspend setting.
        if (!hKeyProfile || !FsdLoadFlag(hKeyProfile, g_szDISABLE_ON_SUSPEND, &m_dwFlags, STORE_FLAG_DISABLE_ON_SUSPEND)) {
            FsdLoadFlag(hKeyStorage, g_szDISABLE_ON_SUSPEND, &m_dwFlags, STORE_FLAG_DISABLE_ON_SUSPEND);
        }

        // Load the MountAsXXX and MountFlags values from the profile key.
        g_pMountTable->GetMountSettings(hKeyStorage, &m_dwDefaultMountFlags); // First read from base profile.
        g_pMountTable->GetMountSettings(hKeyProfile, &m_dwDefaultMountFlags); // Override values using storage profile.

        // Load the Attrib settings.
        DWORD dwAttribs = 0;
        if (!hKeyProfile || !FsdGetRegistryValue(hKeyProfile, g_szATTRIB_STRING, &dwAttribs)) {
            FsdGetRegistryValue(hKeyStorage, g_szATTRIB_STRING, &dwAttribs);
        }

        // We currently only honor the read-only attribute of the store.
        if (dwAttribs & STORE_ATTRIBUTE_READONLY) {
            m_dwFlags |= STORE_ATTRIBUTE_READONLY;
        }

    }

    // Determine the name of the partition driver and partition driver dll to use
    // for this storage device.
    if (!GetPartitionDriver(hKeyStorage, hKeyProfile)) {
        goto ExitFalse;
    }

    // Set-up the LogicalDisk_t registry values so that the partition driver can read 
    // its own settings using FSDMGR_GetRegistryXXX functions.
    if (ERROR_SUCCESS != AddRootRegKey (m_szRootRegKey) ||
        ERROR_SUCCESS != SetRegSubKey (m_szPartDriverName)) {
        goto ExitFalse;
    }
    
    bRet = TRUE;
ExitFalse:
    if (hKeyStorage) {
        FsdRegCloseKey( hKeyStorage);
    }
    if (hKeyProfile) {
        FsdRegCloseKey( hKeyProfile);
    }
    return bRet;
}

BOOL StoreDisk_t::IsValidPartition(PartitionDisk_t * pPartition)
{
    PartitionDisk_t *pTemp = m_pPartitionList;
    if (!pPartition || (pPartition == INVALID_PARTITION))
        return FALSE;
    while(pTemp) {
        if (pTemp == pPartition) {
            break;
        }
        pTemp = pTemp->m_pNextPartition;
    }
    return pTemp != NULL;
}

DWORD StoreDisk_t::OpenDisk()
{
    DWORD dwError = ERROR_SUCCESS;
    STORAGE_IDENTIFICATION storageid;

    if (m_pBlockDevice) {

        m_hDisk = m_pBlockDevice->OpenBlockDevice ();
        if (INVALID_HANDLE_VALUE == m_hDisk) {
            dwError = ::FsdGetLastError ();
        }
        
    } else {
        m_hDisk = ::CreateFileW (m_szDeviceName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL, OPEN_EXISTING, 0, NULL);

        if (m_hDisk == INVALID_HANDLE_VALUE) {
            dwError = ::FsdGetLastError ();
            if (dwError == ERROR_ACCESS_DENIED) {
                dwError = ERROR_SUCCESS;
                m_hDisk = ::CreateFileW (m_szDeviceName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL, OPEN_EXISTING, 0, NULL);
                if (m_hDisk != INVALID_HANDLE_VALUE) {
                    m_dwFlags |= STORE_ATTRIBUTE_READONLY;
                } else {
                    dwError = ::FsdGetLastError ();
                }
            }
        }
    }
    if (INVALID_HANDLE_VALUE != m_hDisk) {

        DWORD dwRet;
        dwError = DiskIoControl (DISK_IOCTL_GETINFO, &m_di, sizeof(DISK_INFO), NULL, 0, &dwRet, NULL);
        if ((dwError == ERROR_BAD_COMMAND) || (dwError == ERROR_NOT_SUPPORTED)){
            ::memset (&m_di, 0, sizeof(DISK_INFO));
            dwError = ERROR_SUCCESS;
        }
        
        if (dwError == ERROR_SUCCESS) {
            
            if (ERROR_SUCCESS != DiskIoControl (IOCTL_DISK_DEVICE_INFO, &m_sdi, sizeof(STORAGEDEVICEINFO), NULL, 0, &dwRet, NULL)) {
                DEBUGMSG (ZONE_ERRORS, (L"FSDMGR!StoreDisk_t::OpenDisk(0x%08X) call to IOCTL_DISK_DEVICE_INFO failed..filling info\r\n", this));
                m_sdi.dwDeviceClass = STORAGE_DEVICE_CLASS_BLOCK;
                m_sdi.dwDeviceFlags = STORAGE_DEVICE_FLAG_READWRITE;
                m_sdi.dwDeviceType = STORAGE_DEVICE_TYPE_UNKNOWN;

                // In the case that a disk does not respond to IOCTL_DISK_DEVICE_INFO, use
                // the profile name "Default"
                VERIFY (SUCCEEDED (::StringCchCopy (m_sdi.szProfile, PROFILENAMESIZE, L"Default")));
            }
        }

        DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::OpenDisk(0x%08X) DeviceInfo Class(0x%08X) Flags(0x%08X) Type(0x%08X) Profile(%s)\r\n",
            this,
            m_sdi.dwDeviceClass,
            m_sdi.dwDeviceFlags,
            m_sdi.dwDeviceType,
            m_sdi.szProfile));
        
        SetLastError (ERROR_SUCCESS);
        storageid.dwSize = 0;
        // Get the storage ID.  The returned error should be ERROR_INSUFFICIENT_BUFFER. 
        // Allocate enough space for the ID.  If storageid.dwSize is 0, 
        // then the call failed and should not be attempted a second time.
        if ((ERROR_INSUFFICIENT_BUFFER == DiskIoControl (IOCTL_DISK_GET_STORAGEID, NULL, 0, &storageid, sizeof(STORAGE_IDENTIFICATION), &dwRet, NULL))&&(storageid.dwSize != 0)){
            m_pStorageId = new BYTE[storageid.dwSize];
            DiskIoControl (IOCTL_DISK_GET_STORAGEID, NULL, 0, m_pStorageId, storageid.dwSize, &dwRet, NULL);
        }
    }
    return dwError;
}

void StoreDisk_t::AddPartition(PartitionDisk_t *pPartition)
{
    if (m_pPartitionList) {
        PartitionDisk_t *pTemp = m_pPartitionList;
        while(pTemp->m_pNextPartition) {
            pTemp = pTemp->m_pNextPartition;
        }
        pTemp->m_pNextPartition = pPartition;
    } else {
        m_pPartitionList = pPartition;
    }
}

void StoreDisk_t::DeletePartition(PartitionDisk_t * pPartition)
{
    PartitionDisk_t *pTemp = m_pPartitionList;
    if (m_pPartitionList == pPartition) {
        m_pPartitionList = pPartition->m_pNextPartition;
    } else {
        while(pTemp) {
            if (pTemp->m_pNextPartition && (pTemp->m_pNextPartition == pPartition)) {
                break;
            }
            pTemp = pTemp->m_pNextPartition;
        }
        if (pTemp) {
            pTemp->m_pNextPartition = pPartition->m_pNextPartition;
        }
    }
    UpdateHandleFromList(m_pRootHandle, NULL, pPartition);
    delete pPartition;
}

PartitionDisk_t *StoreDisk_t::FindPartition(LPCTSTR szPartitionName)
{
    PartitionDisk_t *pPartition = m_pPartitionList;
    while( pPartition) {
        if (wcsicmp(pPartition->m_szPartitionName, szPartitionName) == 0) {
            break;
        }
        pPartition = pPartition->m_pNextPartition;
    }
    return pPartition;
}

void StoreDisk_t::GetPartitionCount()
{
    DWORD dwSearchId;
    m_dwPartCount = 0;
    if (ERROR_SUCCESS == m_pPartDriver->FindPartitionStart(m_dwStoreId, &dwSearchId)) {
        PD_PARTINFO pi;
        while( ERROR_SUCCESS == m_pPartDriver->FindPartitionNext(dwSearchId, &pi)) {
            m_dwPartCount++;
        }
        m_pPartDriver->FindPartitionClose(dwSearchId);
    }
}



BOOL StoreDisk_t::LoadPartition(LPCTSTR szPartitionName, BOOL bMount, BOOL bFormat)
{
    DWORD dwPartitionId;
    HANDLE hPartition = NULL;

    if (ERROR_SUCCESS == m_pPartDriver->OpenPartition(m_dwStoreId, szPartitionName, &dwPartitionId)) {

        PartitionDisk_t *pPartition = new PartitionDisk_t(this, m_dwStoreId, dwPartitionId, m_pPartDriver, m_szFolderName, m_pBlockDevice);
        if (!pPartition) {
            m_pPartDriver->ClosePartition(dwPartitionId);
            return FALSE;
        }

        if (!pPartition->LoadPartition(szPartitionName, m_szRootRegKey)) {
            delete pPartition;
            m_pPartDriver->ClosePartition(dwPartitionId);
            return FALSE;
        }

        AddPartition(pPartition);

        // Attempt to mount the partition if the store is being mounted (bMount == TRUE)
        // and auto-mount is set in the registry profile. 
        if (bMount && (m_dwFlags & STORE_ATTRIBUTE_AUTOMOUNT)) {

            // Open a private handle to the partition and mount it.
            HANDLE hProc = reinterpret_cast<HANDLE>(GetCurrentProcessId());
            if (ERROR_SUCCESS == OpenPartition(szPartitionName, &hPartition, hProc)) {

                DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::LoadPartition: mounting partition "
                    L"\"%s\" on store \"%s\"", pPartition->m_szPartitionName, m_szDeviceName));
 
                if (bFormat) {
                    pPartition->SetFormatOnMount(TRUE);
                }

                // Try to mount the partition. If this fails for some reason, we
                // intentionally still succeed the LoadPartition call.
                if (pPartition->MountPartition(hPartition)) {

                    m_dwMountCount++;
                
                } else {
#ifdef UNDER_CE
                    ::CloseHandle (hPartition);
#else
                    ::STG_CloseHandle (reinterpret_cast<PSTOREHANDLE> (hPartition));
#endif
                }
            }
        }
        return TRUE;
    }
    return FALSE;
}

void StoreDisk_t::LoadExistingPartitions(BOOL bMount, BOOL bFormat)
{
    DWORD dwSearchId;
    if (ERROR_SUCCESS == m_pPartDriver->FindPartitionStart(m_dwStoreId, &dwSearchId)) {
        PD_PARTINFO pi;
        while( ERROR_SUCCESS == m_pPartDriver->FindPartitionNext(dwSearchId, &pi)) {
            DEBUGMSG( 1, (L"Partition %s  NumSectors=%ld\r\n", pi.szPartitionName,  (DWORD)pi.snNumSectors));
            LoadPartition(pi.szPartitionName, bMount, bFormat);
        }
        m_pPartDriver->FindPartitionClose(dwSearchId);
    }
}


DWORD StoreDisk_t::MountStore(HANDLE hStore, BOOL bMount)
{
    DWORD dwError = ERROR_GEN_FAILURE;
    BOOL bFormat = FALSE;

    // We have a handle to this store.
    m_hStore = hStore;

    if(ERROR_SUCCESS == (dwError = OpenDisk())) {
        if (GetStoreSettings()) {
            m_pPartDriver = new PartitionDriver_t();
            if (!m_pPartDriver) {
                return ERROR_OUTOFMEMORY;
            }
            if (ERROR_SUCCESS == (dwError = m_pPartDriver->LoadPartitionDriver(m_szPartDriver))) {
#ifdef UNDER_CE
                dwError = m_pPartDriver->OpenStore( m_hDisk, &m_dwStoreId );
#else
                // Pass the store handle rather than the disk handle to the partition driver 
                // so it will trap back into STG_DeviceIoControl when calling DeviceIoControl.
                dwError = m_pPartDriver->OpenStore( m_hStore, &m_dwStoreId );
#endif
                if (ERROR_DEVICE_NOT_PARTITIONED == dwError) {
                    if (m_dwStoreId)
                        m_pPartDriver->CloseStore( m_dwStoreId);
                    delete m_pPartDriver;
                    VERIFY( SUCCEEDED(::StringCchCopyW ( m_szPartDriver, MAX_PATH, L"")));
                    m_pPartDriver = new PartitionDriver_t();
                    if (!m_pPartDriver) {
                        return ERROR_OUTOFMEMORY;
                    }
                    dwError = m_pPartDriver->LoadPartitionDriver(m_szPartDriver);
                    if (ERROR_SUCCESS == dwError) {
                        dwError = m_pPartDriver->OpenStore( m_hDisk, &m_dwStoreId );
                    }
                }
                if (ERROR_SUCCESS == dwError) {
                    // Activity Timer Setup
                    if ((STORE_FLAG_ACTIVITYTIMER & m_dwFlags) && wcslen( m_szActivityName)) {
                        m_hActivityEvent = CreateEvent( NULL, FALSE, FALSE, m_szActivityName);
                        // there is really nothing we can do if event creation fails
                        DEBUGCHK(m_hActivityEvent);
                    }
                    DEBUGMSG(ZONE_INIT, (L"FSDMGR!StoreDisk_t::MountStore: Opened the store \"%s\" hStore=0x%08X\r\n", 
                        m_szDeviceName, m_dwStoreId));
                    m_si.cbSize = sizeof(PD_STOREINFO);
                    m_pPartDriver->GetStoreInfo( m_dwStoreId, &m_si);
                    DEBUGMSG(ZONE_INIT, (L"FSDMGR!StoreDisk_t::MountStore: Geometry: NumSec=%ld BytesPerSec=%ld FreeSec=%ld BiggestCreatable=%ld\r\n", 
                        (DWORD)m_si.snNumSectors, (DWORD)m_si.dwBytesPerSector, (DWORD)m_si.snFreeSectors, 
                        (DWORD)m_si.snBiggestPartCreatable));
                    if (ERROR_SUCCESS != m_pPartDriver->IsStoreFormatted(m_dwStoreId)) {
                        if (m_dwFlags & STORE_ATTRIBUTE_AUTOFORMAT) {
                            // TODO: Check for failure
                            m_pPartDriver->FormatStore(m_dwStoreId);
                            m_pPartDriver->GetStoreInfo( m_dwStoreId, &m_si);
                        }
                    }
                    if (ERROR_SUCCESS == m_pPartDriver->IsStoreFormatted(m_dwStoreId)) { // Retry again if we formatted it
                        GetPartitionCount();
                        if (!m_dwPartCount) {
                            if (m_dwFlags & STORE_ATTRIBUTE_AUTOPART) {
                                PD_STOREINFO si;
                                si.cbSize = sizeof(PD_STOREINFO);
                                m_pPartDriver->GetStoreInfo(m_dwStoreId, &si);
                                if ( (ERROR_SUCCESS == m_pPartDriver->CreatePartition(m_dwStoreId, L"PART00", 0, si.snBiggestPartCreatable, TRUE)) &&
                                     (ERROR_SUCCESS == m_pPartDriver->FormatPartition(m_dwStoreId, L"PART00", 0, TRUE))) {
                                        m_pPartDriver->GetStoreInfo( m_dwStoreId, &m_si);
                                        DEBUGMSG( 1, (L"FSDMGR!StoreDisk_t::MountStore: Geometry: NumSec=%ld BytesPerSec=%ld FreeSec=%ld BiggestCreatable=%ld\r\n", 
                                            (DWORD)m_si.snNumSectors, (DWORD)m_si.dwBytesPerSector, 
                                            (DWORD)m_si.snFreeSectors, (DWORD)m_si.snBiggestPartCreatable));
                                        m_dwPartCount = 1;
                                        bFormat = TRUE;
                                }
                            }
                        }
                        LoadExistingPartitions(bMount, bFormat);
                    }
                    m_dwFlags |= STORE_FLAG_MOUNTED;
                    if (m_pBlockDevice) {
                        m_pBlockDevice->AdvertiseInterface(m_szDeviceName, TRUE);
                    }
                }
            }
        }
    }
    return dwError;
}

void StoreDisk_t::DisableStore ()
{
    PartitionDisk_t *pPartition = m_pPartitionList;
    while(pPartition) {
        // Disable the volume associate with this partition.
        // It will be reenabled if the disk comes back online.
        pPartition->DisablePartition ();
        pPartition = pPartition->m_pNextPartition;
    }
}

void StoreDisk_t::EnableStore ()
{
    PartitionDisk_t *pPartition = m_pPartitionList;
    while(pPartition) {
        // Enable the volume associated with this partition.
        pPartition->EnablePartition ();
        pPartition = pPartition->m_pNextPartition;
    }
}

BOOL StoreDisk_t::UnmountStore(BOOL bDelete)
{
    // Always disable prior to unmounting, force disable without
    // waiting for threads.
    DisableStore ();
    
    PartitionDisk_t *pPartition = m_pPartitionList;
    while( pPartition) {
        if (pPartition->IsPartitionMounted()) {
            if (pPartition->UnmountPartition()) {
                m_dwMountCount--;
            } else {
                pPartition = pPartition->m_pNextPartition;
                continue;
            }
        }
        if (bDelete) {
            m_pPartitionList = pPartition->m_pNextPartition;
            UpdateHandleFromList(m_pRootHandle, NULL, pPartition);
            delete pPartition;
            pPartition = m_pPartitionList;
        } else {
            pPartition = pPartition->m_pNextPartition;
        }
    }

    if (m_pBlockDevice) {
        m_pBlockDevice->AdvertiseInterface(m_szDeviceName, FALSE);
    }
    
    return (m_dwMountCount == 0);
}

DWORD StoreDisk_t::FormatStore()
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (m_dwMountCount) {
        dwError = ERROR_DEVICE_IN_USE;
    }
    else if (m_dwFlags & STORE_ATTRIBUTE_READONLY) {
        dwError = ERROR_ACCESS_DENIED;
    }
    else if (ERROR_SUCCESS == (dwError = m_pPartDriver->FormatStore( m_dwStoreId))) {
        if (m_dwFlags & STORE_FLAG_MOUNTED) {
            UnmountStore();
        }
        m_dwPartCount = 0;
        m_si.cbSize = sizeof(PD_STOREINFO);
        m_pPartDriver->GetStoreInfo(m_dwStoreId, &m_si);
        // TODO: Should we auto partition here ???
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::CreatePartition(LPCTSTR szPartitionName, BYTE bPartType, SECTORNUM snNumSectors, BOOL bAuto)
{
    DWORD dwError = ERROR_SUCCESS;

    Lock();
    if (snNumSectors == 0) {
        snNumSectors = m_si.snBiggestPartCreatable;
    }
    if (ERROR_SUCCESS == (dwError = m_pPartDriver->CreatePartition(m_dwStoreId, szPartitionName, bPartType, snNumSectors, bAuto))) {
        m_pPartDriver->GetStoreInfo(m_dwStoreId, &m_si);
        // Load up the new partition
        LoadPartition(szPartitionName, TRUE, TRUE);
        m_dwPartCount++;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::DeletePartition(LPCTSTR szPartitionName)
{
    DWORD dwError = ERROR_SUCCESS;
    PartitionDisk_t *pPartition;

    Lock();
    if (pPartition = FindPartition( szPartitionName)) {
        if (pPartition->IsPartitionMounted()) {
           dwError = ERROR_DEVICE_IN_USE;
        } else {
           if (ERROR_SUCCESS == (dwError = m_pPartDriver->DeletePartition(m_dwStoreId, szPartitionName))) {
               DeletePartition(pPartition);
               m_pPartDriver->GetStoreInfo(m_dwStoreId, &m_si);
               m_dwPartCount--;
           }
        }
    }
     Unlock();
    return dwError;
}

DWORD StoreDisk_t::OpenPartition(LPCTSTR szPartitionName, HANDLE *pbHandle, HANDLE hProc)
{
    DWORD dwError = ERROR_SUCCESS;
    STOREHANDLE *pStoreHandle = new STOREHANDLE;
    *pbHandle = INVALID_HANDLE_VALUE;
    if (!pStoreHandle) {
        return ERROR_OUTOFMEMORY;
    }
    Lock();
    if (pStoreHandle->pPartition = FindPartition(szPartitionName)) {
        pStoreHandle->pStore = this;
        pStoreHandle->pNext = NULL;
        pStoreHandle->dwFlags = 0;
        pStoreHandle->dwSig = PART_HANDLE_SIG;
        if (hProc == reinterpret_cast<HANDLE> (GetCurrentProcessId())) {
            pStoreHandle->dwFlags |= STOREHANDLE_TYPE_INTERNAL;
        }
        pStoreHandle->hProc = hProc;
    } else {
        delete pStoreHandle;
        pStoreHandle = NULL;
    }
    Unlock();
    if (pStoreHandle) {
        // Create a kernel handle for this store handle object.
        HANDLE h = CreateAPIHandle( g_hStoreApi, pStoreHandle);
        if (h == INVALID_HANDLE_VALUE) {
            dwError = ::FsdGetLastError (ERROR_GEN_FAILURE);
            delete pStoreHandle;
        } else {
            // Successfully created a handle.
            Lock ();            
            AddHandleToList(&m_pRootHandle, pStoreHandle);
            Unlock ();
        }
        // Output the handle value, valid or invalid.
        *pbHandle = h;
    } else {
        dwError = ERROR_FILE_NOT_FOUND;
    }
    return dwError;
}

DWORD StoreDisk_t::MountPartition(PartitionDisk_t * pPartition)
{
    HANDLE hPartition;
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (pPartition->IsPartitionMounted()){
            dwError = ERROR_ALREADY_EXISTS;
        } else {

            // Open a private handle to the partition.
            HANDLE hProc = reinterpret_cast<HANDLE>(GetCurrentProcessId());
            dwError = OpenPartition( pPartition->m_szPartitionName, &hPartition, hProc);
            if (ERROR_SUCCESS == dwError) {

                DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::MountPartition: mounting partition "
                    L"\"%s\" on store \"%s\"", pPartition->m_szPartitionName, m_szDeviceName));

                // Mount the partition.
                if (pPartition->MountPartition(hPartition)) {

                    m_dwMountCount++;

                } else {
                    dwError = ::FsdGetLastError();
#ifdef UNDER_CE
                    ::CloseHandle (hPartition);
#else
                    ::STG_CloseHandle (reinterpret_cast<PSTOREHANDLE> (hPartition));
#endif
                }
            }
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::UnmountPartition(PartitionDisk_t * pPartition)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (!pPartition->IsPartitionMounted()){
            dwError = ERROR_FILE_NOT_FOUND;
        } else {
            DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::UnmountPartition: unmounting partition "
                L"\"%s\" on store \"%s\"", pPartition->m_szPartitionName, m_szDeviceName));
            
            if (pPartition->UnmountPartition()) {
                m_dwMountCount--;
            } else {
                dwError = ERROR_GEN_FAILURE;
            }
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}


void StoreDisk_t::MediaDetachFromPartition (PartitionDisk_t* pPartition)
{
    DEBUGCHK (!(PARTITION_FLAG_MEDIA_DETACHED & pPartition->m_dwInternalFlags));

    MountedVolume_t* pVolume = pPartition->GetVolume ();
    if (pVolume)
    {
        // Notify the volume that the media has been detached. The FSD will
        // likely just ignore this message, and we don't care how it responds.
        pVolume->MediaChangeEvent (
            StorageMediaChangeEventDetached,
            NULL
            );
    }

    // Add the "media detached" partition flag so we don't try to detach 
    // again.
    pPartition->m_dwInternalFlags |= PARTITION_FLAG_MEDIA_DETACHED;
}

void StoreDisk_t::MediaDetachFromStore ()
{
    if (STORE_FLAG_MEDIA_DETACHED & m_dwFlags)
    {
        // Already detached.
        return;
    }

    // Disable the store so that it cannot be accessed any more.
    DisableStore ();

    // Notify the volume that the media has been detached. The partition driver
    // will likely just ignore this message, and we don't care how it responds.
    m_pPartDriver->MediaChangeEvent (
            m_dwStoreId,
            StorageMediaChangeEventDetached,
            NULL);

    PartitionDisk_t *pPartition = m_pPartitionList;
    while(pPartition)
    {
        // Disable the volume associate with this partition.
        // It will be reenabled if the disk comes back online.
        MediaDetachFromPartition (pPartition);
        pPartition = pPartition->m_pNextPartition;
    }

    // Mark the store with the "media detached" flag.
    m_dwFlags |= STORE_FLAG_MEDIA_DETACHED;
}

void StoreDisk_t::MediaAttachToPartition (PartitionDisk_t* pPartition)
{
    MountedVolume_t* pVolume = pPartition->GetVolume ();
    if (pVolume)
    {
#ifdef DEBUG
        WCHAR VolumeName[32] = {0};
        FSDMGR_GetVolumeName (pVolume->GetVolumeHandle (), VolumeName, 32);
        DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::MediaAttachToPartition: attaching media to \"%s\"\r\n", VolumeName));
#endif
        // The FSD should report back either "changed" or "unchanged."
        STORAGE_MEDIA_ATTACH_RESULT Result = StorageMediaAttachResultUnchanged;

        // Notify the volume that the media has been attached. The FSD will
        // report back status on whether or not it recognizes the media as
        // the same media that was previously detached.
        if ((ERROR_SUCCESS == pVolume->MediaChangeEvent (
                StorageMediaChangeEventAttached, &Result)) &&
            (StorageMediaAttachResultChanged == Result))
        {
#ifdef DEBUG
            DEBUGMSG (ZONE_INIT, (L"FSDMGR!StoreDisk_t::MediaAttachToPartition: media at \"%s\" changed! refreshing...\r\n", VolumeName));
#endif
            // The FSD has indicated that the volume has changed, so we 
            // need to refresh it. We do this by simply unmounting and re-
            // mounting this partition, which will force the FSD to unload
            // and re-load.
            if (ERROR_SUCCESS == UnmountPartition (pPartition))
            {
                // This may fail.
                MountPartition (pPartition);
            }
        }
        // else, the FSD did not recognise the event or indicated that the media
        // has not changed. In this case, just keep the volume mounted.
    }
    else // !pVolume
    {
        // There is currently no volume associated with this partition, so try
        // to mount it.
        MountPartition (pPartition);
    }

    // Clear the "media detached" partition flag if it is set.
    pPartition->m_dwInternalFlags &= ~PARTITION_FLAG_MEDIA_DETACHED;
}

void StoreDisk_t::MediaAttachToStore ()
{
    // The partition driver should report back either "changed" or "unchanged."
    STORAGE_MEDIA_ATTACH_RESULT Result = StorageMediaAttachResultUnchanged;

    // Query the partition driver to determine if its view of the underlying
    // media has changed (e.g. geometry, partition count, etc). It is possible
    // the same media was just reinserted, and, if so, we don't need to bother
    // tearing down and reconstructing partition information.
    if (NO_ERROR == m_pPartDriver->MediaChangeEvent (
            m_dwStoreId,
            StorageMediaChangeEventAttached,
            &Result
            ) &&
        (StorageMediaAttachResultUnchanged == Result))
    {
        // The partition driver indicates that its view of the media has not
        // changed, so enumerate and re-attach each partition individually.
        PartitionDisk_t *pPartition = m_pPartitionList;
        while(pPartition)
        {
            MediaAttachToPartition (pPartition);
            pPartition = pPartition->m_pNextPartition;
        }

        // Re-enable the store. Partitions that were refreshed are already 
        // enabled and will be skipped.
        EnableStore ();
    }
    else
    {
        // If the partition driver fails the call or indicates that the media
        // has changed, then refresh the store. This will re-load the partition
        // driver and re-enumerate and mount all partitions. The store remains
        // disabled until it is refreshed.
        m_dwFlags |= STORE_FLAG_REFRESHED;
    }

    // Clear the "media detached" flag(s) if they're set.
    m_dwFlags &= ~(STORE_FLAG_MEDIA_DETACHED | STORE_FLAG_MEDIA_DETACH_COMPLETE);
}

DWORD StoreDisk_t::RenameParttion(PartitionDisk_t * pPartition, LPCTSTR szNewName)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (!pPartition->RenamePartition(szNewName)) {
            GetDriverError(&dwError);
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}



DWORD StoreDisk_t::SetPartitionAttributes(PartitionDisk_t * pPartition, DWORD dwAttrs)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (!pPartition->SetPartitionAttributes(dwAttrs)) {
            GetDriverError(&dwError);
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::SetPartitionSize(PartitionDisk_t *pPartition, SECTORNUM snNumSectors)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)) {
        if (!pPartition->SetPartitionSize(snNumSectors)) {
            GetDriverError(&dwError);
        } else {
            m_pPartDriver->GetStoreInfo(m_dwStoreId, &m_si);
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::GetPartitionInfo(PartitionDisk_t * pPartition, PPARTINFO pInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (!pPartition->GetPartitionInfo(pInfo)) {
            dwError = ERROR_BAD_ARGUMENTS;
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}


DWORD StoreDisk_t::FormatPartition(PartitionDisk_t *pPartition, BYTE bPartType, BOOL bAuto)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (IsValidPartition(pPartition)){
        if (!pPartition->FormatPartition(bPartType, bAuto)) {
            GetDriverError( &dwError);
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::FindFirstPartition(PPARTINFO pInfo, HANDLE * pHandle, HANDLE hProc)
{
    DWORD dwError = ERROR_SUCCESS;
    *pHandle = INVALID_HANDLE_VALUE;
    SEARCHPARTITION*pSearch = new SEARCHPARTITION;
    if (!pSearch) {
        return ERROR_OUTOFMEMORY;
    }
    Lock();
    if (m_pPartitionList) {
        pSearch->pStore = this;
        pSearch->pPartition = m_pPartitionList;
        pSearch->pPartition->GetPartitionInfo( pInfo);
        pSearch->pNext = NULL;
        pSearch->dwFlags = STOREHANDLE_TYPE_SEARCH;
        pSearch->hProc = hProc;
        pSearch->dwSig = PART_HANDLE_SIG;
        AddHandleToList(&m_pRootHandle, pSearch);
        *pHandle = CreateAPIHandle(g_hFindPartApi, pSearch);
    } else {
        delete pSearch;
        dwError = ERROR_NO_MORE_ITEMS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::FindNextPartition(PSEARCHPARTITION pSearch, PARTINFO *pInfo)
{
    DWORD dwError = ERROR_NO_MORE_ITEMS;
    Lock();
    if (IsValidPartition(pSearch->pPartition)) {
        if (pSearch->dwFlags & STOREHANDLE_TYPE_CURRENT) {
            pSearch->dwFlags &= ~STOREHANDLE_TYPE_CURRENT;
        } else {
            pSearch->pPartition= pSearch->pPartition->m_pNextPartition;
        }
        if (pSearch->pPartition && (pSearch->pPartition != INVALID_PARTITION)) {
            pSearch->pPartition->GetPartitionInfo( pInfo);
            dwError = ERROR_SUCCESS;
        }
    } else {
        dwError = ERROR_BAD_ARGUMENTS;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::FindClosePartition(PSEARCHPARTITION pSearch)
{
    DWORD dwError = ERROR_SUCCESS;
    Lock();
    if (DeleteHandleFromList(&m_pRootHandle, pSearch)) {
        delete pSearch;
    } else {
        dwError = ERROR_INVALID_OPERATION;
    }
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::GetStorageId(PVOID pOutBuf, DWORD nOutBufSize, DWORD *pBytesReturned)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwSize;
    Lock();
    if (NULL == m_pStorageId) {
        dwError = ERROR_NOT_SUPPORTED;
    } else {
        dwSize = ((STORAGE_IDENTIFICATION *)m_pStorageId)->dwSize;
        if (nOutBufSize >= dwSize) {
            if (!CeSafeCopyMemory(pOutBuf, m_pStorageId, dwSize)) {
                dwError = ERROR_INVALID_PARAMETER;
            }
           if (pBytesReturned && !CeSafeCopyMemory(pBytesReturned, &dwSize, sizeof(DWORD))) {
                dwError = ERROR_INVALID_PARAMETER;
            }   
        } else {
            dwError = ERROR_INSUFFICIENT_BUFFER;
             // copy the size of the ID
            if (!CeSafeCopyMemory(&((STORAGE_IDENTIFICATION *)pOutBuf)->dwSize, &dwSize, sizeof(DWORD))) {
                dwError = ERROR_INVALID_PARAMETER;
            }
        }
    }   
    Unlock();
    return dwError;
}

DWORD StoreDisk_t::GetDeviceInfo(STORAGEDEVICEINFO *pDeviceInfo, DWORD *pBytesReturned)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwSize = sizeof(STORAGEDEVICEINFO);
    Lock();
    if (!CeSafeCopyMemory(pDeviceInfo, &m_sdi, dwSize) ||
        (pBytesReturned && !CeSafeCopyMemory(pBytesReturned, &dwSize, sizeof(DWORD)))) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    Unlock();
    return dwError;
}

// SECURITY NOTE: Invoked only by STG_DeviceIoControl which is responsible for verifying
// that the caller has permission to perform the IOCTL operation.
DWORD StoreDisk_t::StoreIoControl(PartitionDisk_t *pPartition, DWORD dwIoControlCode, PVOID pInBuf, DWORD nInBufSize, PVOID pOutBuf, DWORD nOutBufSize, PDWORD pBytesReturned)
{
    if (IsValidPartition(pPartition))
    {
        // perform a partition IOCTL
        return pPartition->DiskIoControl(dwIoControlCode, pInBuf, nInBufSize, pOutBuf, nOutBufSize, pBytesReturned, NULL);
    }
    else
    {
        // perform a store IOCTL on this LogicalDisk_t object.
        return DiskIoControl (dwIoControlCode, pInBuf, nInBufSize, pOutBuf, nOutBufSize, pBytesReturned, NULL);
    }
}

void StoreDisk_t::SignalActivity ()
{
    if (m_hActivityEvent) {
        ::SetEvent (m_hActivityEvent);
    }
}

LRESULT StoreDisk_t::GetName (WCHAR* pDiskName, DWORD NameChars)
{
    if (FAILED (::StringCchCopy (pDiskName, NameChars, m_szDeviceName))) {
        return ERROR_INSUFFICIENT_BUFFER;
    } else {
        return ERROR_SUCCESS;
    }
}

HANDLE StoreDisk_t::GetDeviceHandle ()
{
    return m_hStore;
}


/*  direct access to i/o control for a store. intended for use by the partition driver to
    directly access the store. this is the implementation for the abstract LogicalDisk_t class
 */
 
#ifdef UNDER_CE

LRESULT StoreDisk_t::DiskIoControl (DWORD IoControlCode, void* pInBuf, DWORD InBufBytes,
    void* pOutBuf, DWORD nOutBufBytes,  DWORD* pBytesReturned, OVERLAPPED* pOverlapped)
{
    BOOL fRet;
    if (m_pPartDriver) {
        // If we have a partition driver, let it handle the store IOCTL first.
        fRet = m_pPartDriver->StoreIoControl (m_dwStoreId, m_hDisk, IoControlCode,
            pInBuf, InBufBytes, pOutBuf, nOutBufBytes, pBytesReturned, pOverlapped);
    } else {
        // Pass the IOCTL directly to the disk.
        fRet = ::DeviceIoControl (m_hDisk, IoControlCode, pInBuf, InBufBytes,
            pOutBuf, nOutBufBytes, pBytesReturned, pOverlapped);
    }
    return fRet ? ERROR_SUCCESS : FsdGetLastError (ERROR_GEN_FAILURE);
}

#else // UNDER_CE

LRESULT StoreDisk_t::DiskIoControl (DWORD IoControlCode, void* pInBuf, DWORD InBufBytes, 
    void* pOutBuf, DWORD nOutBufBytes,  DWORD* pBytesReturned, OVERLAPPED* pOverlapped)
{
    BOOL fRet;
    // This is not really a handle under NT but a BlockDevice_t object.
    fRet = ::FS_DevDeviceIoControl (reinterpret_cast<BlockDevice_t*> (m_hDisk), IoControlCode, pInBuf, InBufBytes,
        pOutBuf, nOutBufBytes, pBytesReturned, pOverlapped);

    return fRet ? ERROR_SUCCESS : FsdGetLastError (ERROR_GEN_FAILURE);
}

#endif // UNDER_CE

BOOL StoreDisk_t::CompareStores (StoreDisk_t *pStore)
{
    BOOL fRet = FALSE;

    if (m_pStorageId && pStore->m_pStorageId) {

        DWORD Size1 = 
            ((STORAGE_IDENTIFICATION*)(m_pStorageId))->dwSize;
        DWORD Size2 = 
            ((STORAGE_IDENTIFICATION*)(pStore->m_pStorageId))->dwSize;

        if (Size1 != Size2) {
            // Storage IDs are different sizes.
            goto exit;
        }

        if (0 != memcmp(m_pStorageId, pStore->m_pStorageId, Size1)) {
            // Storage IDs are not the same.
            goto exit;
        }

    } else {

        if (m_pStorageId && !pStore->m_pStorageId) {
            // Store 1 has an ID, Store 2 does not.
            goto exit;
        }

        if (!m_pStorageId && pStore->m_pStorageId) {
            // Store 2 has an ID, Store 1 does not.
            goto exit;
        }
    }

    if (0 != memcmp(&m_di, &pStore->m_di, sizeof(DISK_INFO))) {
        // Disk geometry is different.
        goto exit;
    }

    if (0 != memcmp(&m_si, &pStore->m_si, sizeof(PD_STOREINFO))) {
        // Store info is different.
        goto exit;
    }

    if (0 != memcmp(&m_sdi, &pStore->m_sdi, 
                sizeof(STORAGEDEVICEINFO))) {
        // Storage device info is different.
        goto exit;
    }

    if (m_dwPartCount != pStore->m_dwPartCount) {
        // Different number of partitions.
        goto exit;
    }

    // Next, check with the partition driver to see if it detects a change.
    // If so, this is the only check we need to make. If not, then perform
    // more in-depth partition comparisons.
    STORAGE_MEDIA_ATTACH_RESULT Result = StorageMediaAttachResultUnchanged;
    if (ERROR_SUCCESS == m_pPartDriver->MediaChangeEvent (m_dwStoreId,
        StorageMediaChangeEventAttached, &Result) &&
        (StorageMediaAttachResultChanged == Result))
    {
        // Partition driver indicates a change, so skip comparing each 
        // partition individually.
        goto exit;
    }

    // Store compare as the same, now compare every partition.
    PartitionDisk_t *pPartitionThis = m_pPartitionList;
    PartitionDisk_t *pPartition = pStore->m_pPartitionList;

    while (pPartitionThis && pPartition) {

        if (!pPartitionThis->ComparePartitions (pPartition)) {
            break;
        }

        pPartitionThis = pPartitionThis->m_pNextPartition;
        pPartition = pPartition->m_pNextPartition;
    }

    if (pPartitionThis || pPartition) {
        // If one of the partitions is non-NULL after the loop exits
        // we either hit the break or there is a mismatch in partition
        // count.
        goto exit;
    }

    // If we got here, then the stores and all partitions on them match.
    fRet = TRUE;

exit:
    return fRet;
}

